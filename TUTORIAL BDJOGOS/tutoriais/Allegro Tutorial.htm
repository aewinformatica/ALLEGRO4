<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3c.org/TR/1999/REC-html401-19991224/loose.dtd">
<!-- saved from url=(0069)http://www.emunix.emich.edu/~evett/GameProgramming/allegro_howTo.html -->
<HTML><HEAD><TITLE>Allegro Tutorial</TITLE>
<META http-equiv=Content-Type content="text/html; charset=iso-8859-1">
<META content="MSHTML 6.00.2900.2180" name=GENERATOR></HEAD>
<BODY>
<H1>Programming with Allegro:</H1>
<P>Most of the source code from this site is from Johnathon Harbour's <EM>Game 
Programming All in One, 2nd Ed.</EM>, Thomson Course Technology, Boston, 2005. 
</P>
<H2>Basic 2-D Graphics </H2>
<P>Accessing system information via Allegro: <A 
href="http://www.emunix.emich.edu/~evett/GameProgramming/BookCode/chapter02.new/getinfo/main.c">getinfo.c</A>. 
Note use of #include "allegro.h", the call to allegro_init() and END_OF_MAIN(). 
The last is a macro that takes care of win_main stuff on Microsoft platforms. 
The readkey() function pulls a character from STDIN.</P>
<P>Our first exposure to the graphics capabilities of Allegro is in <A 
href="http://www.emunix.emich.edu/~evett/GameProgramming/BookCode/chapter02.new/helloworld/main.c">helloworld.c</A>. 
The gfx_mode call sets the screen resolution. There are many options for the 
mode. The GFX_SAFE provides for a window of the specified dimension, rather than 
trying to force the entire screen to that, which might result in an error (in 
which case check <EM>allegro_error</EM>). The final two args are v_w and v_h 
which are used to specify a larger virtual screen for use with hardware 
scrolling and page flipping.</P>
<P>The textout call makes use of two of Allegro's global variables, screen and 
font. The other arguments are the x-y coordinates as well as a color index. (Use 
makecol() to create other colors.) The index is into the current (256) color 
table. In the default table, colors 0-15 are basic. </P>
<P>Here's a simple program to draw lots of lines, <A 
href="http://www.emunix.emich.edu/~evett/GameProgramming/BookCode/chapter03.new/lines/main.c">lines.c</A>. 
Notice the use of <EM>line</EM> and the <EM>makecol</EM> functions. Also note 
the use of the global <EM>key</EM> array to determine when a key has been 
pressed. The array is constantly updated. (Consequently, it is possible for a 
key to be pressed and released before your program tests the array value!)</P>
<P>The <A 
href="http://www.emunix.emich.edu/~evett/GameProgramming/BookCode/chapter03.new/dolines/main.c">dolines.c</A> 
program demonstrates the use of callback functions by Allegro. The user provides 
a pointer to a function that is to draw each of the pixels comprising a line. 
</P>
<P>There are functions for drawing rectangles and filled rectangles 
(<EM>rect</EM> and <EM>rectfill</EM>) as well as circle and ellipses 
(<EM>circle</EM>, <EM>circlefill</EM>, <EM>ellipse</EM> and 
<EM>ellipsefill</EM>). The <EM>spline</EM> function takes an array of 8 
integers, acting as 4 x-y pairs and renders a smooth curve that passes through 
those points. The <EM>polygon</EM> function takes an array of 2<EM>v</EM> 
integers, representing the coordinates of the <EM>v</EM> vertices defining the 
polygon, as demonstrated in <A 
href="http://www.emunix.emich.edu/~evett/GameProgramming/BookCode/chapter03.new/polygons/main.c">polygons.c</A>. 
</P>
<P>The <A 
href="http://www.emunix.emich.edu/~evett/GameProgramming/BookCode/chapter03.new/floodfill/main.c">floodfill.c</A> 
program demonstrates the use of floodfilling as well as a simple animation (a 
bouncing ball). </P>
<P>There are two basic functions for text output: <EM>textout</EM>, which print 
to a given x-y coordinate, and <EM>textprintf</EM>, which does the same thing 
but allows for formatting using C's <EM>printf</EM> syntax. There are also 
methods to left, right, and center justify text. The program <A 
href="http://www.emunix.emich.edu/~evett/GameProgramming/BookCode/chapter03.new/textoutput/main.c">textoutput.c</A> 
demonstrates this. </P>
<H2>A First Game: Tankwar</H2>
<P>The code of <A 
href="http://www.emunix.emich.edu/~evett/GameProgramming/BookCode/chapter04.new/tankwar/main.c">tankwar.c</A> 
and <A 
href="http://www.emunix.emich.edu/~evett/GameProgramming/BookCode/chapter04.new/tankwar/tankwar.h">tankwar.h</A> 
illustrate many of the basic components of an interactive game. Start by looking 
at the <EM>main</EM> method. Notice the initialization code. The 
<EM>install_timer</EM> code is necessary to provide platform-independent access 
to system clocks and timers. This is used in the <EM>rest</EM> function later. 
The <EM>keypressed</EM> function is a non-blocking call to see if the keyboard 
input buffer has anything. (Note that <EM>readkey</EM> blocks until input if 
found.)</P>
<P><EM>num</EM> is used as an index to select from among the two tanks. The 
tanks and their bullets are represented by structs (see <A 
href="http://www.emunix.emich.edu/~evett/GameProgramming/BookCode/chapter04.new/tankwar/tankwar.h">tankwar.h</A>.)</P>
<P>The <EM>rest</EM> function yields the CPU to the OS, so you don't know for 
sure when you might get more cycles. Still, this is a good idea on most 
platforms, unless you like listening to the fan!</P>
<P>To be honest, the code, here, is pretty ugly. A number of software 
engineering rules are flagrantly violated. How many can you identify? How would 
you improve the code?</P>
<H2>Programming the Keyboard and Mouse</H2>
<P>The <EM>install_keyboard </EM>call sets up a keyboard event handler that sets 
the values in the global <EM>key</EM> array. (See allegro.h for the large number 
of KEY_... constants to be used as indices into the array. Note that the "A" key 
generates two keystrokes, KEY_SHIFT and KEY_A. The <EM>poll_keyboard</EM> 
function can be used if the operating system does not support events. </P>
<P>For buffered key input use <EM>readkey</EM> or <EM>ureadkey </EM>(for 
unicode) . The <EM>set_keyboard_rate</EM> controls the rate at which keys are 
generated when a key is held down. The global <EM>key_shifts</EM> can be used to 
dynamically query which meta keys are held down. E.g: </P>
<P>if ((key_shifts &amp; KB_CTRL_FLAG) &amp;&amp; (readkey() == 13))</P>
<P>If you want you can simulate key presses (perhaps to demo or test your 
program) via the <EM>simulate_keypress</EM> function. </P>
<P>Mouse input</P>
<P>As with the keyboard, Allegro provides both poll- and event-based interaction 
with the mouse. The <EM>poll_mouse</EM> and <EM>mouse_needs_poll</EM> functions 
can be used together for poll-based interaction. </P>
<P>extern volatile int mouse_x, mouse_y, mouse_z, mouse_b </P>
<P>The first 3 variables provide position, and access to the mouse wheel. The 
last is accessed to determine which buttons have been pushed:</P>
<P>if (mouse_b &amp; 1) // left mouse button pushed. 2 for right, 4 for center. 
</P>
<P>The set_mouse_sprite function is used to change the appearance of the mouse. 
The function set_mouse_sprite_focus redefines the "center" of the sprite. The 
sprite is treated as "transparent". I.e., one of the colors is treated as 
transparent. Use the <EM>show_mouse</EM> function with double-buffering to 
control to where the cursor will be rendered. <EM>scare_mouse</EM> and 
<EM>unscare_mouse</EM> are used to turn the cursor off and on. The program <A 
href="http://www.emunix.emich.edu/~evett/GameProgramming/BookCode/chapter05.new/defense/main.c">strategicCommand.c</A> 
illustrates the use of the mouse. You'll also need the bitmaps <A 
href="http://www.emunix.emich.edu/~evett/GameProgramming/BookCode/chapter05.new/defense/city.bmp">city.bmp</A> 
and <A 
href="http://www.emunix.emich.edu/~evett/GameProgramming/BookCode/chapter05.new/defense/crosshair.bmp">crosshair.bmp</A>. 
</P>
<P>The function <EM>position_mouse</EM> let's you move the cursor. Its use, as 
well as a sprite's, is demonstrated in <A 
href="http://www.emunix.emich.edu/~evett/GameProgramming/BookCode/chapter05.new/positionmouse/main.c">positionMouse.c</A> 
and <A 
href="http://www.emunix.emich.edu/~evett/GameProgramming/BookCode/chapter05.new/positionmouse/spaceship.bmp">spaceship.bmp</A>. 
</P>
<P>If you want to use the mouse as in a first person shooter, you'll want 
relative movement. For that, use <EM>get_mouse_mickeys</EM>.</P>
<P>void get_mouse_mickeys(int *deltax, int *deltay)</P>
<P>Timers and Threads</P>
<P>There are two many goals here: prevent games from running too quickly on 
faster CPUs, prevent games from running too slowly on slow CPUs. Let's tackle 
the second problem first. We should have a target frame rate of between 30 and 
60. (More is okay.) A problem arises when the amount of work, including drawing 
operations, rendering single frame is greater than 1/30th of a second. We don't 
want the game speed to slow down in this case. An example will help: suppose it 
takes 1/10 of a second to render the graphics of a single frame of animation, 
but it takes virtually no time to calculate the positions of the objects within 
each frame. If our game loop looked like this: </P><PRE>loop:
  updateObjectPositions();
  renderObjects();
  </PRE>
<P>..then the position of our objects would change every 10th of a second. If we 
then moved to a faster platform where the frame rendering took only 1/30th of a 
second, the game would run three times faster!</P>
<P>To solve this problem we want to invoke the updateObjectPositions() method 
three times per iteration on the slow platform. That way, even though the frames 
are redrawn only every 1/10 of a second, the objects will have moved as much as 
they would have moved in 1/10 of a second on the faster machine.</P>
<P>To solve this problem we can use a timer to increment a counter at a fixed 
interval, say once every 30th of a second. In our main loop, we maintain a 
second counter. If the second counter is out of synch with the first, we can 
iterate over the updateObjectPositions() enough times to make up for the delay. 
The program from the Allegro Vicace tutorial demonstrates this: </P>
<P><A 
href="http://www.emunix.emich.edu/~evett/GameProgramming/AllegroVivaceCode/0943.c">0943.c 
</A><A 
href="http://www.emunix.emich.edu/~evett/GameProgramming/AllegroVivaceCode/0943.h">0943</A><A 
href="http://www.emunix.emich.edu/~evett/GameProgramming/AllegroVivaceCode/0943i.c">.h 
0943i.c </A><A 
href="http://www.emunix.emich.edu/~evett/GameProgramming/AllegroVivaceCode/0943i.h">0943i</A>.h</P>
<P>Note the use of Allegro's LOCK_VARIABLE, LOCK_FUNCTION, END_OF_FUNCTION 
macros. (The use syntax for the last of these is particularly odd.) These assure 
that a virtual memory OS will never swap this code or these variables out of 
memory. Note, too, the use of the "<EM>volatile</EM>" keyword, which precludes 
the compiler from optimizing these variables into register or cache memory. This 
is to prevent problems that can occur when an interrupt handler modifies data 
values shared by other threads.</P>
<P>A word about interrupt handlers: Allegro provides for up to 16, but needs 
some of those for itself. The code in these should be very brief, and all 
variables that are changed therein must be protected by LOCK_VARIABLE calls. The 
handlers, and any functions that they invoke should be protected by a 
LOCK_FUNCTION call (which, in turn, requires the use of the END_OF_FUNCTION 
macros.)</P>
<P>The BPS_TO_TIMER macro indicates how many hardware clock ticks will occur 
between each frame if the given number of frames per second is to be achieved. 
The Allegro clock should tick 1193181 times per second. Thus, 1193 ticks equals 
1 msec. (These figures are important if you use the <EM>install_int_ex</EM> 
functions.) </P>
<P>To use the 0943 program, note the speed of the bouncing ball when the program 
first starts, along with the frame rate. Now use the + on the keypad to increase 
the number of pixels being drawn each frame. When this gets very high, you will 
see the frame rate has decreased below 60fps. But the ball appears to be moving 
at the same speed. This is because the ball's position is still being modified 
60 times per second, even if the ball is only be drawing at the reduced frame 
rate.</P>
<P>Okay, the second problem is how to keep the game from running too quickly on 
a fast platform. The 0943 program does this by busy waiting: the frames are 
drawn as quickly as possible, but the ball's position in only updated at most 
once per 60th of a second (see <EM>game_loop</EM>). This works, but means that 
the CPU's use will be maxed out. Instead, it is better to yield control to the 
CPU until a frame needs to be redrawn.</P>
<P>The timedloop program from Harbour's book illustrates a technique: </P>
<P><A href="Allegro Tutorial_arquivos/background.bmp"><IMG height=32 
src="Allegro Tutorial_arquivos/background.bmp" width=32></A> <A 
href="Allegro Tutorial_arquivos/bee.bmp"><IMG height=32 
src="Allegro Tutorial_arquivos/bee.bmp" width=32></A> <A 
href="Allegro Tutorial_arquivos/crab.bmp"><IMG height=32 
src="Allegro Tutorial_arquivos/crab.bmp" width=32></A> <A 
href="Allegro Tutorial_arquivos/dragon.bmp"><IMG height=32 
src="Allegro Tutorial_arquivos/dragon.bmp" width=32></A> <A 
href="Allegro Tutorial_arquivos/fish.bmp"><IMG height=32 
src="Allegro Tutorial_arquivos/fish.bmp" width=32></A> <A 
href="http://www.emunix.emich.edu/~evett/GameProgramming/BookCode/chapter11.new/timedloop/main.c">main.c</A> 
<A href="Allegro Tutorial_arquivos/skeeter.bmp"><IMG height=32 
src="Allegro Tutorial_arquivos/skeeter.bmp" width=32></A> <A 
href="Allegro Tutorial_arquivos/snake.bmp"><IMG height=32 
src="Allegro Tutorial_arquivos/snake.bmp" width=32>.</P></A>
<P>Allegro's rest_callback(n, fnc) rests for n msecs, repeatedly calling *fnc 
until that time has elapsed. This code relays on a hard-coded number of 
milliseconds to wait between each game loop. A better way would be to calculate 
this value dynamically, in response to the values of counters such as in the 
0943 program. </P>
<P><A href="http://allegro.cc/manual/api/timer-routines/">Full documentation for 
Allegro's timer routines</A> is on their site. </P>
<H2>Bitmap Manipulation</H2>
<P>Just about everything drawn in a game is sprites. Each of these, including 
the background, is encoded as a bitmap. Allegro has a BITMAP struct to represent 
these. The global <EM>screen</EM> is a pointer to the screen's current 
bitmap.</P><PRE>extern BITMAP *screen</PRE>
<P>(See allegro.h if you really want to know the insides of the data structure.) 
The function for generating a new bitmap is simple enough:</P><PRE>BITMAP *create_bitmap(int w, int h)</PRE>
<P>which creates a bitmap with the current color depth. Use the _ex version of 
this function if you want to use a different color depth. To clear a bitmap 
quickly, use</P><PRE>void clear_bitmap(BITMAP *bmap)
</PRE>
<P>Or the clear_to_color function to clear to something other than 0 (black). 
</P>
<P>We can create sub bitmaps of other bitmaps. The interesting aspect here is 
that the two continue to share the same underlying memory, so changes to one can 
affect the other. This can be particularly handy if you want to alter only a 
portion of the screen bitmap.</P><PRE>BITMAP *create_sub_bitmap(BITMAP *parent, int x, y, w, h)</PRE>
<P>Use <EM>destroy_bitmap </EM>to free the allocated bitmap structures. There 
are various functions to gather information about bitmaps 
(<EM>is_screen_bitmap</EM>, e.g.). See the documentation for these.</P>
<P>When Allegro draws to a bitmap, it must first lock the bitmap, which 
precludes any other process from altering it. This involves a system call, so 
can be rather slow. If the game is going to effect several drawing operations on 
a bitmap, it pays to lock it just once, do the operations, then unlock it. Your 
friends are:</P><PRE>void acquire_bitmap(BITMAP *bmp), acquire_screen()
</PRE>
<P>Along with their corresponding <EM>release_</EM> partners. </P>
<P>You can restrict the clipping rectangle within a bitmap via </P><PRE>void set_clip(BITMAP *bmp, int x1, y1, x2, y2)
</PRE>
<P>The most common way to load bitmaps is from a file. Check the documentation 
for a number of functions that allow this from various types of image files. In 
addition, there are several <EM>save_</EM> operations that allow the dumping of 
an existing bitmap to an external file.</P>
<H3>Blitting:</H3>
<P>The basic blitting functions are </P><PRE>void blit(BITMAP *src, *dest, int srcX, srcY, destX, destY, w, h)
void stretch_blit(BITMAP *src, *dest, int srcX, srcY, srcW, srcH, destX, destY, destW, destH)</PRE>
<P>The masked blit operation does not overwrite the destination pixels where the 
source pixels are pink (255, 0, 255). </P>
<P>This version of tankwar.c generates bitmaps during initialization which are 
then used throughout the game: <A 
href="http://www.emunix.emich.edu/~evett/GameProgramming/BookCode/chapter07.new/tankwar_r2/main.c">main.c 
</A><A 
href="http://www.emunix.emich.edu/~evett/GameProgramming/BookCode/chapter07.new/tankwar_r2/tankwar.h">tankwar.h 
</A>.</P>
<H3>Basic Sprite Programming:</H3>
<P>We can just use the blit operators to paint sprites. Allegro provides a 
number of functions, though, that provide more advanced capabilities, including 
translucency, lighting effects, etc. The basic drawing operation assumes the 
default transparency color (255,0,255) in the sprite bitmap:</P><PRE>void draw_sprite(BITMAP *src, *sprite, int x, y)</PRE>
<P></P>
<P>The assumption is that the entire sprite will be rendered, so there is no w 
or h arguments. Usually multiple sprite images are encoded in a single external 
file (a larger bitmap). The sprites are then sub bitmaps of the larger map. The 
program drawsprite ( <A href="Allegro Tutorial_arquivos/spacedragon1.bmp"><IMG 
height=32 src="Allegro Tutorial_arquivos/spacedragon1.bmp" width=32></A> <A 
href="http://www.emunix.emich.edu/~evett/GameProgramming/BookCode/chapter08.new/drawsprite/main.c">main</A>) 
illustrates the use of this function. If you change the color depth from 16 to 8 
the transparency effect will be lost. </P>The <EM>stretch_sprite</EM> function 
does the same thing, but takes an additional w and h argument to alter the size 
of the sprite. The ScaledSprite program <A 
href="Allegro Tutorial_arquivos/spacecowboy1.bmp"><IMG height=32 
src="Allegro Tutorial_arquivos/spacecowboy1.bmp" width=32></A> <A 
href="http://www.emunix.emich.edu/~evett/GameProgramming/BookCode/chapter08.new/scaledsprite/main.c">main</A> 
demonstrates this. There are also functions for flipping and rotating sprites. 
<P></P><PRE>void rotate_sprite(BITMAP *src, *sprite, int x, y, fixed angle)</PRE>
<P>The rotation argument is weird, because the value is not in degrees, but in a 
value from 0 to 255--a normalization of the degrees. If <EM>d</EM> is the 
degrees, the normalized value is 255*((d%360)/360). Basically, every 45 degrees 
is a rotation of 32. Initialization code often loads a sprite, then use the 
rotation operation to precalculate a set of sprites that represent the original 
in various rotations. The rotateSprite program <A 
href="Allegro Tutorial_arquivos/tank.bmp"><IMG height=32 
src="Allegro Tutorial_arquivos/tank.bmp" width=32></A> <A 
href="http://www.emunix.emich.edu/~evett/GameProgramming/BookCode/chapter08.new/rotatesprite/main.c">main</A> 
demonstrates this. There is also a <EM>pivot_sprite</EM> function that provides 
for a different rotation axis other than the center of the bitmap. See the 
pivotSprite program <A 
href="C:\pagina\Allegro Tutorial_arquivos\tank(1).bmp"><IMG height=32 
src="C:\pagina\Allegro Tutorial_arquivos\tank(1).bmp" width=32></A> <A 
href="http://www.emunix.emich.edu/~evett/GameProgramming/BookCode/chapter08.new/pivotsprite/main.c">main</A> 
here. </P>
<P>Allegro provides for translucency via <EM>alpha blending</EM>. (See 
<EM>set_alpha_blender</EM>.)This technique is quite tricky via Allegro, but is 
possible. You'll want to stay away from it if your platform's video card doesn't 
support it.</P>
<P>Here is a version of the tankWar program, <A 
href="Allegro Tutorial_arquivos/bullet.bmp"><IMG height=32 
src="Allegro Tutorial_arquivos/bullet.bmp" width=32></A> <A 
href="Allegro Tutorial_arquivos/explode.bmp"><IMG height=32 
src="Allegro Tutorial_arquivos/explode.bmp" width=32></A> <A 
href="http://www.emunix.emich.edu/~evett/GameProgramming/BookCode/chapter08.new/tankwar_r3/main.c">main</A> 
<A href="Allegro Tutorial_arquivos/tank1.bmp"><IMG height=32 
src="Allegro Tutorial_arquivos/tank1.bmp" width=32></A> <A 
href="Allegro Tutorial_arquivos/tank2.bmp"><IMG height=32 
src="Allegro Tutorial_arquivos/tank2.bmp" width=32></A> <A 
href="http://www.emunix.emich.edu/~evett/GameProgramming/BookCode/chapter08.new/tankwar_r3/tankwar.h">tankwar</A>, 
but with obstacles removed and the tanks replaced with 8-way rotated bitmaps. 
Pay particular attention to the new explode, updatebullet and fireweapon 
methods. The setuptanks method is also very different from the older versions, 
because it dynamically generates rotated bitmaps.</P>
<H3>Animated Sprites:</H3>
<P>The simplest way to accomplish an animated sprite is to represent each such 
sprite with an array of sprites, each representing a different frame of a short 
animation of that sprite. Associate a frame counter with each animated sprite 
which indicates which element of the array will be used to render the sprite. 
Manipulate this counter to achieve the desired animation. The animsprite program 
( <A href="Allegro Tutorial_arquivos/cat1.bmp"><IMG height=32 
src="Allegro Tutorial_arquivos/cat1.bmp" width=32></A> <A 
href="Allegro Tutorial_arquivos/cat2.bmp"><IMG height=32 
src="Allegro Tutorial_arquivos/cat2.bmp" width=32></A> <A 
href="Allegro Tutorial_arquivos/cat3.bmp"><IMG height=32 
src="Allegro Tutorial_arquivos/cat3.bmp" width=32></A> <A 
href="Allegro Tutorial_arquivos/cat4.bmp"><IMG height=32 
src="Allegro Tutorial_arquivos/cat4.bmp" width=32></A> <A 
href="Allegro Tutorial_arquivos/cat5.bmp"><IMG height=32 
src="Allegro Tutorial_arquivos/cat5.bmp" width=32></A> <A 
href="Allegro Tutorial_arquivos/cat6.bmp"><IMG height=32 
src="Allegro Tutorial_arquivos/cat6.bmp" width=32></A> <A 
href="http://www.emunix.emich.edu/~evett/GameProgramming/BookCode/chapter09.new/animsprite/main.c">main</A> 
) demonstrates this. </P>
<P>Usually, the animation cells are stored in a single bitmap, and the various 
sprites comprising the animation are sub bitmaps. The SpriteGrabber program <A 
href="Allegro Tutorial_arquivos/sphere.bmp"><IMG height=32 
src="Allegro Tutorial_arquivos/sphere.bmp" width=32></A> <A 
href="http://www.emunix.emich.edu/~evett/GameProgramming/BookCode/chapter09.new/spritegrabber/main.c">main</A>(again, 
from Harbour) demonstrates the use of this technique, plus the use of a SPRITE 
struct to encapsulate the information of the animated sprite. </P>
<P>From here it is relatively straight-forward to animate several sprites 
simultaneously. In this example, each sprite is a separate animation consisting 
of the same set of animation frames. Each sprite's current frame position can 
differ from other sprites' (see the <EM>curframe</EM> field of the SPRITE 
struct. Note that each sprite has its own <EM>framedelay</EM> variable.) Each 
sprite also has its own velocity and frame delay. Each sprite is effectively a 
copy of the same movie, but each is being shown at a different rate. Here is the 
code for multiplesprites ( <A href="Allegro Tutorial_arquivos/ngc604.bmp"><IMG 
height=32 src="Allegro Tutorial_arquivos/ngc604.bmp" width=32></A> <A 
href="Allegro Tutorial_arquivos/asteroid.bmp"><IMG height=32 
src="Allegro Tutorial_arquivos/asteroid.bmp" width=32></A> <A 
href="http://www.emunix.emich.edu/~evett/GameProgramming/BookCode/chapter09.new/multiplesprites/main.c">main</A>). 
</P>
<P>So far we've looked at the simplest kind of sprite, a raw bit image. If 
memory is a problem, we may be able to represent the animation cells as 
run-length encode sprites. Allegro has a number of RLE_ operations to support 
this data structure. Note that no image manipulation operations (flipping, 
stretching, etc.) are possible on RLE_SPRITES. Rendering can sometimes be faster 
if the bitmaps contain lots of "transparent" pixels that can be skipped during 
the decompression process. </P>
<P>Allegro also supports compiled sprites. These require quite a bit more 
memory, as each sprite is represented not as an array of pixels values, but as 
machine code, which, when executed, renders the image. See Allegro's 
COMPILED_SPRITE data strucutre and related <EM>_compiled_sprite</EM> functions. 
Here is the code for compiledSprite ( <A 
href="Allegro Tutorial_arquivos/block1.bmp"><IMG height=32 
src="Allegro Tutorial_arquivos/block1.bmp" width=32></A> <A 
href="Allegro Tutorial_arquivos/block2.bmp"><IMG height=32 
src="Allegro Tutorial_arquivos/block2.bmp" width=32></A> <A 
href="C:\pagina\Allegro Tutorial_arquivos\dragon(1).bmp"><IMG height=32 
src="C:\pagina\Allegro Tutorial_arquivos\dragon(1).bmp" width=32></A> <A 
href="http://www.emunix.emich.edu/~evett/GameProgramming/BookCode/chapter09.new/compiledsprites/main.c">main</A>).</P>
<H3>Simple Collision Detection:</H3>
<P>Harbour's collisionTest program ( <A 
href="C:\pagina\Allegro Tutorial_arquivos\sphere(1).bmp"><IMG height=32 
src="C:\pagina\Allegro Tutorial_arquivos\sphere(1).bmp" width=32></A> <A 
href="http://www.emunix.emich.edu/~evett/GameProgramming/BookCode/chapter09.new/collisiontest/main.c">main</A>)generates 
a number of animated billiard balls that bounce off of each other and the sides 
of the window. Each collision changes the sign of the velocity of the ball, but 
may also change its magnitude, so "virtual momentum" is not necessarily 
conserved. This is easy to observe if you concentrate on following just one of 
the balls. The collision algorithm uses a square bounding box around each ball 
that is 10 pixels smaller than a "true" bounding box. The smaller box decreases 
the likelihood of false positives with the collision test, though it does mean 
that the ball images sometimes overlap slightly, if only briefly. The test 
itself merely checks to see if any of the vertices of one bounding box are 
inside the other. (See the <EM>collided</EM> function.) </P>
<P>Here's another version of the tankwar program(). It makes use of sprites for 
animation. I've also added code to detect when the tanks collide. </P>
<H2>Scrolling Tile-Based Terrains :</H2>
<P>The basic idea behind scrolling is simple. We display only a part of a larger 
image that falls within a virtual window, called a <EM>viewport</EM>. Scrolling 
simply moves the virtual window across the larger image. In scrollTest (<A 
href="http://www.emunix.emich.edu/~evett/GameProgramming/BookCode/chapter10.new/scrollscreen/main.c">main)</A>, 
the program first generates a large bitmap, and initializes two variables (x,y) 
to keep track of the current "position" within the map. The screen bitmap is 
init'd to show the upper-left hand portion of the larger bitmap. The arrow keys 
are used to change x and y and thus change that portion of the larger bitmap 
that is displayed. </P>
<P>As virtual terrains become large, it becomes infeasible, or at least 
unwieldly, to store the terrain as a single, very large bitmap. Instead, 
terrains are constructed as a mosaic of tiles. We might several tiles to 
represent forest, several to represent roads, etc. The terrain becomes a grid, 
each cell of which is a reference/pointer to one of the underlying tile types. 
The tileScroll program ( <A href="Allegro Tutorial_arquivos/tiles.bmp"><IMG 
height=32 src="Allegro Tutorial_arquivos/tiles.bmp" width=32></A> <A 
href="http://www.emunix.emich.edu/~evett/GameProgramming/BookCode/chapter10.new/tilescroll/main.c">main</A>)generates 
the underlying terrain map dynamically: randomly blitting terrain tiles onto a 
large bitmap. (See "draw tiles randomly.) </P>
<P>Well, random terrain isn't very interesting. What is needed is a way to 
assign particular tiles to particul locations on the terrain grid. The GameWorld 
program ( <A href="C:\pagina\Allegro Tutorial_arquivos\tiles(1).bmp"><IMG 
height=32 src="C:\pagina\Allegro Tutorial_arquivos\tiles(1).bmp" width=32></A> 
<A 
href="http://www.emunix.emich.edu/~evett/GameProgramming/BookCode/chapter10.new/gameworld/main.c">main</A>) 
does this via the <EM>map</EM> variable, a one-d array masquarading as a 2-d 
grid, whose elements are indices (0-39) to an array of terrain cells. If you 
look at the terrain cells <A 
href="C:\pagina\Allegro Tutorial_arquivos\tiles(1).bmp"><IMG height=32 
src="C:\pagina\Allegro Tutorial_arquivos\tiles(1).bmp" width=32> you can see 
that the last cell is all black. This can be used to render a border, if 
desired. </P></A>
<P>Putting all this together, we get a version of TankWar ( <A 
href="C:\pagina\Allegro Tutorial_arquivos\tiles(2).bmp"><IMG height=32 
src="C:\pagina\Allegro Tutorial_arquivos\tiles(2).bmp" width=32></A> <A 
href="C:\pagina\Allegro Tutorial_arquivos\background(1).bmp"><IMG height=32 
src="C:\pagina\Allegro Tutorial_arquivos\background(1).bmp" width=32></A> <A 
href="C:\pagina\Allegro Tutorial_arquivos\bullet(1).bmp"><IMG height=32 
src="C:\pagina\Allegro Tutorial_arquivos\bullet(1).bmp" width=32></A> <A 
href="http://www.emunix.emich.edu/~evett/GameProgramming/BookCode/chapter10.new/tankwar_r5/bullet.c">bullet, 
</A><A href="C:\pagina\Allegro Tutorial_arquivos\explode(1).bmp"><IMG height=32 
src="C:\pagina\Allegro Tutorial_arquivos\explode(1).bmp" width=32></A> <A 
href="http://www.emunix.emich.edu/~evett/GameProgramming/BookCode/chapter10.new/tankwar_r5/input.c">input.c</A>, 
<A 
href="http://www.emunix.emich.edu/~evett/GameProgramming/BookCode/chapter10.new/tankwar_r5/main.c">main.c</A>, 
<A 
href="http://www.emunix.emich.edu/~evett/GameProgramming/BookCode/chapter10.new/tankwar_r5/map.h">map.h</A>, 
<A 
href="http://www.emunix.emich.edu/~evett/GameProgramming/BookCode/chapter10.new/tankwar_r5/setup.c">setup, 
</A><A href="C:\pagina\Allegro Tutorial_arquivos\tank1(1).bmp"><IMG height=32 
src="C:\pagina\Allegro Tutorial_arquivos\tank1(1).bmp" width=32></A> <A 
href="C:\pagina\Allegro Tutorial_arquivos\tank2(1).bmp"><IMG height=32 
src="C:\pagina\Allegro Tutorial_arquivos\tank2(1).bmp" width=32></A> <A 
href="http://www.emunix.emich.edu/~evett/GameProgramming/BookCode/chapter10.new/tankwar_r5/tank.c">tank, 
</A><A 
href="http://www.emunix.emich.edu/~evett/GameProgramming/BookCode/chapter10.new/tankwar_r5/tankwar.h">tankwar, 
</A>) that features terrain tiles and two scrolling windows, one for each 
player, as well as a zoomed out "radar" view that shows the entire map. Again, a 
<EM>map</EM> array is used to define the terrain in terms of tiles. Note the use 
of border tiles ('B') to define the terrain edge. The program has finally been 
decomposed into several smaller files. bullet.c, for example, contains all the 
code for rendering and manipulating the bullets. Note that when a bullet is 
drawn (<EM>drawbullet</EM>), it is actually rendered in both scrolling windows. 
Note, too, that there is no longer an erase function. This is because the 
scrolling windows redraw their entire content with each frame. </P>
<P>A drawback to this way of handling scrollable terrain is that we are still 
memory-restricted for the size of the underlying bitmap. A better solution in 
such a case is to form the underlying bitmap dynamically--just make sure that 
the portion of the terrain map that has been formed from tiles is bigger than 
the viewport.</P>
<H3>Adding Timer Animation to Tankwar:</H3>
<P>There are several changes in this version of Tankwar( <A 
href="C:\pagina\Allegro Tutorial_arquivos\tiles(3).bmp"><IMG height=32 
src="C:\pagina\Allegro Tutorial_arquivos\tiles(3).bmp" width=32></A> <A 
href="C:\pagina\Allegro Tutorial_arquivos\background(2).bmp"><IMG height=32 
src="C:\pagina\Allegro Tutorial_arquivos\background(2).bmp" width=32></A> <A 
href="C:\pagina\Allegro Tutorial_arquivos\bullet(2).bmp"><IMG height=32 
src="C:\pagina\Allegro Tutorial_arquivos\bullet(2).bmp" width=32></A> <A 
href="http://www.emunix.emich.edu/~evett/GameProgramming/BookCode/chapter11.new/tankwar_r6/bullet.c">bullet</A> 
<A href="C:\pagina\Allegro Tutorial_arquivos\explode(2).bmp"><IMG height=32 
src="C:\pagina\Allegro Tutorial_arquivos\explode(2).bmp" width=32></A> <A 
href="http://www.emunix.emich.edu/~evett/GameProgramming/BookCode/chapter11.new/tankwar_r6/input.c">input</A> 
<A 
href="http://www.emunix.emich.edu/~evett/GameProgramming/BookCode/chapter11.new/tankwar_r6/main.c">main</A> 
<A 
href="http://www.emunix.emich.edu/~evett/GameProgramming/BookCode/chapter11.new/tankwar_r6/map.h">map</A> 
<A 
href="http://www.emunix.emich.edu/~evett/GameProgramming/BookCode/chapter11.new/tankwar_r6/setup.c">setup</A> 
<A href="C:\pagina\Allegro Tutorial_arquivos\tank1(2).bmp"><IMG height=32 
src="C:\pagina\Allegro Tutorial_arquivos\tank1(2).bmp" width=32></A> <A 
href="C:\pagina\Allegro Tutorial_arquivos\tank2(2).bmp"><IMG height=32 
src="C:\pagina\Allegro Tutorial_arquivos\tank2(2).bmp" width=32></A> <A 
href="http://www.emunix.emich.edu/~evett/GameProgramming/BookCode/chapter11.new/tankwar_r6/tank.c">tank</A> 
<A 
href="http://www.emunix.emich.edu/~evett/GameProgramming/BookCode/chapter11.new/tankwar_r6/tankwar.h">tankwar</A>). 
First, the explosion code no longer suspends the game while the explosion is 
being animated. Note the changes in <A 
href="http://www.emunix.emich.edu/~evett/GameProgramming/BookCode/chapter11.new/tankwar_r6/tankwar.h">tankwar.h</A> 
involving the new <EM>explosions</EM>array, as well as the <EM>tank_bmp</EM> 
array (we've added another dimension). Also note the introduction of three 
functions: animatetank, updateexplosion and loadsprites. The main changes to 
setup.c revolve around loading the animation frames for the tank movement. The 
main changes to bullet.c are that explosions are drawing a single-frame at a 
time in updateexplosion. This function, in turn, is invoked once per game loop. 
</P>
<H2>Threads:</H2>
<P>There are several implementations of posix threads on most platforms, 
including Windows, MacOS and Unix/Linux. Their use is not as simple as threads 
in Java, but is sufficient. Here's a quick overview. For a more in depth 
treatment, see on of the many tutorials on-line.</P>
<P>To create a new thread: </P><PRE>int pthread_create(pthread_t *threadID, // a return param
   const pthread_attr_t *attr, // usually, put NULL here
   void *(*start) (void *), // The callback function the thread will invoke
   void *arg);  // An array containing any parameters to that function</PRE>
<P>&nbsp;Here's an example </P><PRE>int id; pthread_t pthread0; int threadID0=0;
id = pthread_create(&amp;pthread0, NULL, thread0, (void*)&amp;threadid0);

void* thread0(void* data) {
  int my_thread_id = *((int*)data;
  while (!done) {
    // do something marvelous!
  }
  pthread_exit(NULL);
  return NULL;
}</PRE>
<P>Now comes the tricky part of threads: protecting against simultaneous access 
to data. For example, we don't want one thread writing to a buffer while another 
thread is blitting it to the screen. Posix provides a data structure called a 
<EM>mutex</EM> to avoid this situation. These act much like binary semaphores, 
if you are familiar with that concept. A thread attempting to lock a mutex that 
has already been locked by another thread will block until the lock is released 
(unlocked). Here's some code demonstrating this:</P><PRE>pthread_mutex_t mySemaphore = PTHREAD_MUTEX_INITIALIZER; // creates a mutex struct
...
 pthread_mutex_lock(&amp;mySemaphore);  // Try to obtain a lock
...
 pthread_mutex_unlock(&amp;mySemaphore);  // Relase the lock.
...
pthread_mutex_destroy(&amp;mySemaphore);  // Must destroy before exiting!!
</PRE>
<P>Okay, with that done, here is a demo program, MultiThread ( <A 
href="C:\pagina\Allegro Tutorial_arquivos\sphere(2).bmp"><IMG height=32 
src="C:\pagina\Allegro Tutorial_arquivos\sphere(2).bmp" width=32></A> <A 
href="http://www.emunix.emich.edu/~evett/GameProgramming/BookCode/chapter11.new/multithread/main.c">main</A>). 
In the code, thread0 is moving one ball, while thread1 moves the other. The 
threads share a single mutex to control access to their shared buffer. Because 
each thread is loop containing a rest() call outside the use of the mutex, there 
is ample opportunity for each thread to work. There should be no threat of 
starvation, or deadlock. The demo uses two different functions, one for each 
thread, but this wasn't really necessary. Each thread could have used the same 
callback function and made use of the argument to tell which thread was 
executing the code.</P>
<H3>Terrain Editing: Mappy</H3>
<P>You can download mappy at <A 
href="http://www.tilemap.co.uk/">http://www.tilemap.co.uk/</A>. Start Mappy, 
create a new map. Then import a bitmap defining a bunch of tiles, such as <A 
href="http://www.emunix.emich.edu/~evett/GameProgramming/BookCode/chapter12.new/testmappy/maptiles.bmp">maptiles.bmp</A>. 
From the Custom menu you can use the Solid Rectangle script to fill the entire 
map with one "default" tile. Mappy can create grid, hexagonal and isometric 
maps. It is also capable of some dynamic terrain elements. Once you've made a 
map, you can save the map in .fmp format. This file encapsulates both the map 
file and the tile images. Do that first, then we'll use mappy to generate code 
that will load the tile images to create a map. Use File:Export... From the 
resulting dialog box, select "Graphics Blocks as picture .BMP" and "Map array as 
comma values only .CSV". This will generate two files, a .BMP and .CSV file. 
Change the .csv extension to .txt and edit it to see what you've got. Take a 
look!</P>
<P>Okay, once you've generated your map and pasted the .csv text into your .c or 
.h file in the appropriate places, you're ready to go. See ArrayMapTest program 
( <A href="Allegro Tutorial_arquivos/maptiles.bmp"><IMG height=32 
src="Allegro Tutorial_arquivos/maptiles.bmp" width=32></A> <A 
href="http://www.emunix.emich.edu/~evett/GameProgramming/BookCode/chapter12.new/arraymaptest/main.c">main</A>)for 
an example. </P>
<P>You can also make use of the MappyAL library to access the .fmp file 
directly, and avoid a lot of this rigamarole. I leave it to you to work this out 
from the documentation at the Mappy web site. (Basically you download the Mappy 
.zip file and extract the mappyal.c and .h file and integrate them into your 
program. While the mappyAL API makes it a lot easier to load the maps, it is 
restricted to only work with 256-color bitmaps.) </P>
<H3>A Vertical Scroller</H3>
<P>The Harbour book comes with a <A 
href="http://www.emunix.emich.edu/~evett/GameProgramming/BookCode/chapter13.new/verticalscroller.zip">nice 
vertical scroller demo</A>. This demo allows the player to scroll up and down 
across a very large map. The map has been created with Mappy, and is the maximum 
size allowable by Mappy: 640 x 48,000 pixels. I.e., about 32K tiles. Each tile, 
in this case, is 32x32 pixels. <A 
href="http://www.emunix.emich.edu/~evett/GameProgramming/BookCode/chapter13.new/verticalscroller/main.c">The 
code</A> is quite small because most of the scrolling work is done by Mappy's 
API (see, especially, MapDrawBG and MapLoad). The map provided with the demo was 
generated with Mappy. The "islands" were generated by a Lua script run inside 
Mappy. </P>
<P><A 
href="http://www.emunix.emich.edu/~evett/GameProgramming/BookCode/chapter13.new/warbirds.zip">The 
code</A> (here's just the driver, <A 
href="http://www.emunix.emich.edu/~evett/GameProgramming/BookCode/chapter13.new/verticalscroller/main.c">main.c</A>.) 
illustrates the major components of implementing a full vertical-scroller game. 
This game also uses a Mappy .fmp file to store the map. </P>
<H3>A Horizontal Scroller</H3>
<P>Harbour provides <A 
href="http://www.emunix.emich.edu/~evett/GameProgramming/BookCode/chapter14.new/platformscroller.zip">another 
nice demo</A>, this one of a horizontal scroller, in the mold of <EM>Super 
Mario...</EM>. The major topic introduced by the coding of demo is a more 
advanced use of Mappy to provide collision detection and background maps. When 
you run the demo you will see a single character controlled by the left &amp; 
right arrow keys as well as the space bar (for jumping). The character falls 
when walking off of blocks and can jump onto higher blocks. There is a 
background pattern that scrolls by as the character moves to the left or right. 
The background does not scroll vertically when the character jumps or falls, 
however.</P>
<P>First, obtain or generate a bitmap image 640x480 pixels, X. This will 
represent the background of the scroller. You should try to engineer the bitmap 
so that its left and right edges appear to flow into each other. Here's <A 
href="C:\pagina\Allegro Tutorial_arquivos\background(3).bmp"><IMG height=32 
src="C:\pagina\Allegro Tutorial_arquivos\background(3).bmp" width=32>an example 
of such an image</A>. Now, using your bitmap editor, create a new bitmap, Y, 
combining X with the <A href="Allegro Tutorial_arquivos/blocks1.bmp"><IMG 
height=32 src="Allegro Tutorial_arquivos/blocks1.bmp" width=32>bitmap of the 
terrain blocks</A>. The combined bitmap should have X at the top and the image 
of the terrain blocks below. Leave some empty space at the bottom of the image 
if you want to be able to add new terrain tiles later. If you want, you can use 
<A href="Allegro Tutorial_arquivos/blocks2.bmp"><IMG height=32 
src="Allegro Tutorial_arquivos/blocks2.bmp" width=32>this sample</A>. </P>
<P>Now start Mappy to set up the background and terrain tiles. First, run Mappy 
and create an empty 640x480 pixel map, with each tile being 32x32, and 16 bit 
color. Now, back in Mappy, use the MapTools-&gt;Useful Functions-&gt;Create Map 
from Big Picture menu item and select Y. The result will be a bunch of tiles, 
which, when laid out as a mosaic will form the original background image. </P>
<P>Now, because we want the map to be quite a lot larger, use the 
MapTools-&gt;Resize Map command to change the size of the map to be quite a bit 
larger horizontally (and vertically insofar as you want to accomodate vertical 
scrolling.) I chose 1000 tiles by 15, but you could choose anything so long as 
the total number of tiles is &lt; 30,000.</P>
<P>This leaves quite a lot of black (empty) space to the right of our original 
background. Rather than painstakingly painting each of those, we'll replicate 
the background repeatedly to the right until filling the entire map. To do that, 
use the Brush menu to create a "brush" that consists of the entire background 
map. Note that the resulting map structure uses very little memory, since the 
entire map is formed from only several dozen 32x32 tiles. </P>
<H3>Terrain Blocks</H3>
<P>Next, to enable collision detection via Mappy we need to label the terrain 
tiles as "foreground" rather than "background" tiles. We also want to makr each 
of the terrain tiles as being involved in collision detection. This is somewhat 
difficult to explain, so just look at <A 
href="http://www.emunix.emich.edu/~evett/GameProgramming/mappyForegroundTiles.htm">this 
Flash movie I've made</A>. We can actually perform this manuever on all the 
tiles we want simultaneously by using the MapEdit-&gt;Range Edit Blocks command. 
Here's <A 
href="http://www.emunix.emich.edu/~evett/GameProgramming/mappyRangeEdit.htm">a 
movie demonstrating how to do that</A>. </P>
<P>The program handles collision detection by checking the where the character 
is currently located via the mappyal API. Mappy encodes a simple struct, BLKSTR, 
with each tile. Of particular interest to us are the four unsigned char fields 
named tl, tr, bl and br. Their value will be 0 or 1, indicating whether we 
checked the corresponding collision box in Mappy. These represent the top-left, 
top-right, bottom-left and bottom-right corners of the cell. Given the (x,y) 
pixel coordinates of the character, it is easy to check if the character is over 
a tile for which collision is enabled:</P><PRE>int collided(int x, int y)
{
    BLKSTR *blockdata;
	blockdata = MapGetBlock(x/mapblockwidth, y/mapblockheight);
	return blockdata-&gt;tl;
}</PRE>
<P>Harbour's mechanism for handling jumps and drops is somewhat cryptic. I leave 
you to examine <A 
href="http://www.emunix.emich.edu/~evett/GameProgramming/BookCode/chapter14.new/platformscroller/main.c">the 
code</A> to determine how this works. Pay particular attention to the variable 
<EM>jump</EM> and the constant <EM>JUMPIT</EM>. </P>
<H2>Sound</H2>
<P>Allegro's sounds capabilities are somewhat limited, but certainly up to the 
task of handling the sound for most traditional game genres. Allegro works well 
with .wav and .voc (from Creative Labs, manufacturers of lots of sound card 
drivers) files, so you'll probably want to use those. The mechanism for handling 
these is fairly easy. First, install a digital sound driver. All modern sound 
cards have their own already, so you probably just want to allow Allegro to use 
the card's default:</P><PRE>    //install a digital sound driver
    if (install_sound(DIGI_AUTODETECT, MIDI_NONE, "") != 0) 
    {
        allegro_message("Error initializing sound system");
        return;
    }
 </PRE>
<P>If you wanted to provide MIDI music or something like that, then you'd need 
to vary the arguments to <EM>install_sound</EM>. </P>
<P>Next, load the .wav file into a SAMPLE object. When that is done, it can be 
played via the <EM>play_sample</EM> function. Here's some code that does 
this:</P><PRE>    //load the wave file

    int panning = 128;<BR>    int pitch = 1000;<BR>    int volume = 128;<BR>
    SAMPLE *sample;
    sample = load_sample("clapping.wav");
    if (!sample) 
    {
        allegro_message("Error reading wave file");
        return;
    }

    //play the sample with looping
    play_sample(sample, volume, panning, pitch, TRUE);
</PRE>
<P>The pitch refers to the number of samples per second used to create the .wav 
file. The volume and panning arguments vary from 0 to 255. Panning provides a 
stereo effect: 0 is all left, and 255 is all right. Volume is silent at 0 and 
maximum at 255. You want to be careful with the volumes if you'll be playing 
more than one sounds at a time. Try to keep the sum below 256 to avoid 
distortion, though I think most sound cards handle that on their own these days. 
The fifth argument indicates that the sound should loop. The 
<EM>adjust_sample</EM> function that alters the sound parameters has affect only 
while the sound is playing.</P>
<P>The <A 
href="http://www.emunix.emich.edu/~evett/GameProgramming/BookCode/chapter15.new/playwave/main.c">playWave 
program</A> (along with <A 
href="http://www.emunix.emich.edu/~evett/GameProgramming/BookCode/chapter15.new/playwave/clapping.wav">clapping.wav</A>) 
demonstrates the result of manipulating the panning, pitch and volume during 
playback.</P>
<P>The <A 
href="http://www.emunix.emich.edu/~evett/GameProgramming/BookCode/chapter15.new/samplemixer.zip">sampleMixer 
program</A> demonstrates the result of overdubbing several voices. </P>
<P>Allegro has lots of low-level sample playback routines, which allow much 
tighter control. These might be useful if you want to blend lots of sounds 
simultaneously. In that case you'll need to reserve an appropriate number of 
<EM>voices</EM>, assign samples to each voice, perhaps fiddling with their 
pitch, volume, etc. You can also provide for volume <EM>ramping, 
</EM><EM>frequency sweeps</EM> ("glissando", for you piano buffs out there) and 
<EM>sweeping pans</EM> (a la Pink Floyd's "<A 
href="http://www.emunix.emich.edu/~evett/GameProgramming/pinkFloyd_OnTheRun.mp3">On 
the Run</A>"). </P>
<H3>Tank War c'est Fini!</H3>
<P>Here's the <A 
href="http://www.emunix.emich.edu/~evett/GameProgramming/BookCode/chapter15.new/tankwar_r8.zip">last 
installment of Tank War</A>. This one has sound files added. Perhaps more 
interestingly, Harbour has removed the <EM>rest() </EM>that formerly provided 
the delays to slow the game down to a manageable level. This has been replaced 
with a <EM>key_count</EM> and <EM>key_delay</EM> variables that combine to limit 
how fast the key strokes can be input, thus avoiding unintentionally doubled 
keystrokes. Please examine the code to see the many changes. (There's also a 
certain amount of code added to handle joysticks, but you don't see those around 
much anymore these days...) </P>
<P> </P></BODY></HTML>
