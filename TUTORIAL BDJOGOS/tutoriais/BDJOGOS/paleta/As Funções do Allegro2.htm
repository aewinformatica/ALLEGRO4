<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0070)http://equipe.nce.ufrj.br/adriano/c/apostila/allegro/docs/funcoes.html -->
<HTML><HEAD><TITLE>As Funções do Allegro</TITLE>
<META http-equiv=CONTENT-TYPE content="text/html; charset=iso-8859-1">
<META content="MSHTML 6.00.3790.3959" name=GENERATOR></HEAD>
<BODY>
<TABLE>
  <TBODY>
  <TR>
    <TD><IMG alt="minerva ufrj" hspace=5 
      src="As Funções do Allegro2_files/min_peq.gif" width=80></TD>
    <TD>
      <H3>As Funções do Allegro</H3></TD></TR></TBODY></TABLE><IMG 
alt="barra horizontal azul" hspace=5 
src="As Funções do Allegro2_files/bluebar.gif" width="100%" align=left><BR>©2002 
- Luis Menasché Schechter<BR><BR><I>Powered by vi</I>
<P></P>
<OL>
  <LI><A 
  href="http://equipe.nce.ufrj.br/adriano/c/apostila/allegro/docs/funcoes.html#bas">Funções 
  Básicas</A> 
  <LI><A 
  href="http://equipe.nce.ufrj.br/adriano/c/apostila/allegro/docs/funcoes.html#video">Funções 
  de Vídeo</A> 
  <OL>
    <LI><A 
    href="http://equipe.nce.ufrj.br/adriano/c/apostila/allegro/docs/funcoes.html#video_bas">Funções 
    Básicas de Vídeo</A> 
    <LI><A 
    href="http://equipe.nce.ufrj.br/adriano/c/apostila/allegro/docs/funcoes.html#video_bmp">Funções 
    de Bitmaps</A> 
    <LI><A 
    href="http://equipe.nce.ufrj.br/adriano/c/apostila/allegro/docs/funcoes.html#video_pal">Funções 
    de Paleta</A> 
    <LI><A 
    href="http://equipe.nce.ufrj.br/adriano/c/apostila/allegro/docs/funcoes.html#video_font">Funções 
    de Fonte</A> </LI></OL>
  <LI><A 
  href="http://equipe.nce.ufrj.br/adriano/c/apostila/allegro/docs/funcoes.html#keyboard">Funções 
  de Teclado</A> 
  <LI><A 
  href="http://equipe.nce.ufrj.br/adriano/c/apostila/allegro/docs/funcoes.html#mouse">Funções 
  de Mouse</A> 
  <LI><A 
  href="http://equipe.nce.ufrj.br/adriano/c/apostila/allegro/docs/funcoes.html#sound">Funções 
  de Som</A> 
  <LI><A 
  href="http://equipe.nce.ufrj.br/adriano/c/apostila/allegro/docs/funcoes.html#outras">Outras 
  Funções</A> 
  <OL>
    <LI><A 
    href="http://equipe.nce.ufrj.br/adriano/c/apostila/allegro/docs/funcoes.html#outras_timer">Funções 
    de Timer</A> 
    <LI><A 
    href="http://equipe.nce.ufrj.br/adriano/c/apostila/allegro/docs/funcoes.html#outras_datafile">Funções 
    de DataFile</A> 
    <LI><A 
    href="http://equipe.nce.ufrj.br/adriano/c/apostila/allegro/docs/funcoes.html#outras_config">Funções 
    de Arquivos de Configuração</A> </LI></OL></LI></OL><IMG 
alt="barra horizontal azul" hspace=5 
src="As Funções do Allegro2_files/bluebar.gif" width="100%" align=left><BR><A 
name=bas>
<H2>1. Funções Básicas</H2><A name=bas_allegro_init>
<P><TT><B>int allegro_init();</B></TT><BR><BR>Inicializa a biblioteca Allegro. 
Não faz muita coisa a não ser inicializar algumas variáveis globais e reservar 
memória. Retorna zero em caso de sucesso (na verdade, não é necessário checar se 
a função foi bem sucedida, pois, ao ser usada no início do programa, como é 
recomendada, ela nunca falha). Deve ser a primeira função do Allegro a ser 
chamada.</P><A name=bas_allegro_exit>
<P><TT><B>void allegro_exit();</B></TT><BR><BR>Fecha o Allegro. Isto inclui 
retornar ao modo texto e remover qualquer rotina de mouse, teclado ou 
temporizador que tenha sido instalada. Não há necessidade (embora seja 
recomendável) de chamar explicitamente essa função pois, normalmente, isto é 
feito automaticamente quando o programa termina.</P><IMG 
alt="barra horizontal azul" hspace=5 
src="As Funções do Allegro2_files/bluebar.gif" width="100%" align=left><BR><A 
name=video>
<H2>2. Funções de Vídeo</H2><A name=video_bas>
<H3>2.1. Funções Básicas de Vídeo</H3><A name=video_bas_set_color_depth>
<P><TT><B>void set_color_depth(int depth);</B></TT><BR><BR>Esta função configura 
o número de bits de cores (determinado pelo parâmetro <TT><B>depth</B></TT>) com 
que os gráficos serão exibidos. Os possíveis valores para <TT><B>depth</B></TT> 
são 8, 15, 16, 24 e 32. Esta função deve ser chamada sempre <B>ANTES</B> da 
função <A 
href="http://equipe.nce.ufrj.br/adriano/c/apostila/allegro/docs/funcoes.html#video_bas_set_gfx_mode"><TT>set_gfx_mode</TT></A>.</P><A 
name=video_bas_set_gfx_mode>
<P><TT><B>int set_gfx_mode(int card, int w, int h, int v_w, int 
v_h);</B></TT><BR><BR>Instrui o Allegro a mudar para o modo gráfico. O parâmetro 
<TT><B>card</B></TT> deve ser um dos seguintes valores:<BR><BR></P>
<CENTER>
<TABLE cols=2 width="70%" border=1 ROWS="10">
  <TBODY>
  <TR>
    <TD width="35%">GFX_TEXT</TD>
    <TD>retorna para o modo texto</TD></TR>
  <TR>
    <TD width="35%">GFX_AUTODETECT</TD>
    <TD>faz com que o Allegro escolha o driver gráfico mais apropriado 
      (normalmente tem problemas com placas de vídeo mais recentes)</TD></TR>
  <TR>
    <TD width="35%">GFX_VGA</TD>
    <TD>modo VGA (320x200, 320x100, 160x120, 80x80)</TD></TR>
  <TR>
    <TD width="35%">GFX_MODEX</TD>
    <TD>uma versão planar do modo VGA (tweaked)</TD></TR>
  <TR>
    <TD width="35%">GFX_VESA1</TD>
    <TD>usa o driver VESA 1.x</TD></TR>
  <TR>
    <TD width="35%">GFX_VESA2B</TD>
    <TD>usa o driver VBE 2.0 em modo banked</TD></TR>
  <TR>
    <TD width="35%">GFX_VESA2L</TD>
    <TD>usa o driver VBE 2.0 com framebuffer linear</TD></TR>
  <TR>
    <TD width="35%">GFX_VESA3</TD>
    <TD>usa o driver VBE 3.0</TD></TR>
  <TR>
    <TD width="35%">GFX_VBEAF</TD>
    <TD>usa o acelerador de hardware API VBE/AF</TD></TR>
  <TR>
    <TD width="35%">GFX_XTENDED</TD>
    <TD>usa o driver 640x480 unchained</TD></TR></TBODY></TABLE></CENTER><BR>
<P>Os parâmetros <TT><B>w</B></TT> e <TT><B>h</B></TT> informam o numero de 
pixels existentes, respectivamente, em uma linha e em uma coluna do vídeo. Ex: 
w=800 e h=600.</P>
<P>Os parâmetros <TT><B>v_w</B></TT> e <TT><B>v_h</B></TT> determinam o tamanho 
da tela virtual, ou seja, o tamanho de uma pseudo-tela da qual pode-se 
visualizar apenas um pedaço (determinado pelos parâmetros <TT><B>w</B></TT> e 
<TT><B>h</B></TT>). Para manipular telas virtuais, o Allegro oferece uma série 
de funções de rolamento da tela. Porém, não as abordaremos. Para desabilitar 
este recurso, atribua 0 (zero) a ambos os parâmetros.</P>
<P>O valor retornado por esta função será menor do que 0 (zero) se, e somente 
se, um erro ocorrer. É interessante conferir o valor retornado por esta função, 
de modo a escolher o driver de vídeo adequado, caso o selecionado não funcione. 
Por exemplo:</P><TT>
<OL>#define VIDEO_CARD GFX_VESA1<BR>#define TAM_X 800<BR>#define TAM_Y 
  600<BR>#define ALT_TAM_X 640<BR>#define ALT_TAM_Y 480<BR><BR>(...)<BR><BR>if 
  (set_gfx_mode(VIDEO_CARD, TAM_X, TAM_Y, 0, 0) &lt; 0) {<BR>
  <OL>if (set_gfx_mode(GFX_AUTODETECT, ALT_TAM_X, ALT_TAM_Y, 0, 0) &lt; 0) 
    {<BR>
    <OL>/* Mensagem de erro. */<BR><BR>(...)<BR></OL><BR>}</OL><BR>}<BR></OL></TT>
<HR>
<A name=video_bmp>
<H3>2.2. Funções de Bitmaps</H3>O Allegro trata todos os gráficos que podem ser 
exibidos na tela ou carregados na memória como <U>bitmaps</U>. <U>Bitmaps</U> 
são matrizes de pixels, em que cada valor indica uma cor. Para declarar um 
bitmap, digite: <TT>
<OL>BITMAP *nome_do_bitmap;</OL></TT><A name=video_bmp_screen>
<P><TT><B>extern BITMAP *screen;</B></TT><BR><BR>Para facilitar o uso de suas 
funções de manipulação de bitmaps, o Allegro trata a tela também como um bitmap, 
que é definido no arquivo <TT>allegro.h</TT> como <TT>screen</TT>.</P>
<P>Assim, nas funções de manipulação de bitmaps abaixo, sempre que desejarmos 
apresentar diretamente na tela algum gráfico, passaremos como argumento da 
função a variável <TT>screen</TT>.</P><A name=video_bmp_create_bitmap>
<P><TT><B>BITMAP *create_bitmap(int width, int height);</B></TT><BR><BR>Cria um 
bitmap na memória com largura <TT><B>width</B></TT> e altura 
<TT><B>height</B></TT>. O valor retornado é o do endereço da área de memória 
onde foi alocado o espaço; assim, caso a função retorne <TT><B>NULL</B></TT>, 
significa que não foi possível alocar a memória necessária para armazenar o 
bitmap com as dimensões requisitadas.</P>
<P>É importante notar que a função apenas aloca o espaço, sem "limpá-lo", e, com 
isso, é necessário usar a função <A 
href="http://equipe.nce.ufrj.br/adriano/c/apostila/allegro/docs/funcoes.html#video_bmp_clear"><TT>clear</TT></A> 
ou <A 
href="http://equipe.nce.ufrj.br/adriano/c/apostila/allegro/docs/funcoes.html#video_bmp_clear_to_color"><TT>clear_to_color</TT></A>, 
mencionadas adiante.</P><A name=video_bmp_destroy_bitmap>
<P><TT><B>void destroy_bitmap(BITMAP *bitmap);</B></TT><BR><BR>Destrói o bitmap 
apontado por <TT><B>bitmap</B></TT>, liberando a memória ocupada por este.</P><A 
name=video_bmp_load_bitmap>
<P><TT><B>BITMAP *load_bitmap(char *filename, PALETTE 
pal);</B></TT><BR><BR>Carrega um bitmap de um arquivo, cujo nome é 
<TT><B>filename</B></TT>, e carrega a paleta por ele usada no endereço apontado 
por <TT><B>pal</B></TT>. O tipo do arquivo (BMP, LBM, PCX, TGA) é informado 
através da extensão do mesmo. Deve-se destruir o bitmap após o uso com a função 
<A 
href="http://equipe.nce.ufrj.br/adriano/c/apostila/allegro/docs/funcoes.html#video_bmp_destroy_bitmap"><TT>destroy_bitmap</TT></A>. 
A função retorna um NULL se houver algum erro no carregamento do arquivo.</P>
<P><TT><B>int save_bitmap(char *filename, BITMAP *bmp, PALETTE 
pal);</B></TT><BR><BR>Salva o bitmap apontado por <TT><B>bmp</B></TT>, com a 
paleta apontada por <TT><B>pal</B></TT>, no arquivo de nome 
<TT><B>filename</B></TT>. O tipo do arquivo (BMP, LBM, PCX, TGA) é informado 
através da extensão do mesmo. A função retorna um número diferente de zero caso 
ocorra algum erro.</P><A name=video_bmp_clear>
<P><TT><B>void clear(BITMAP *bitmap);</B></TT><BR><BR>Limpa o bitmap apontado 
por <TT><B>bitmap</B></TT> para a cor 0 (zero).</P><A 
name=video_bmp_clear_to_color>
<P><TT><B>void clear_to_color(BITMAP *bitmap, int color);</B></TT><BR><BR>Limpa 
o bitmap apontado por <TT><B>bitmap</B></TT> para a cor especificada por 
<TT><B>color</B></TT>.</P>
<P><TT><B>void putpixel(BITMAP *bmp, int x, int y, int 
color);</B></TT><BR><BR>Desenha um ponto, no bitmap apontado por 
<TT><B>bmp</B></TT>, na coordenada (x, y), utilizando a cor especificada por 
<TT><B>color</B></TT>.</P>
<P><TT><B>int getpixel(BITMAP *bmp, int x, int y);</B></TT><BR><BR>Retorna o 
código de cor da coordenada (x, y) no bitmap apontado por <TT><B>bmp</B></TT>; 
retorna -1 caso o ponto esteja fora do bitmap.</P>
<P><TT><B>void line(BITMAP *bmp, int x1, int y1, int x2, int y2, int 
color);</B></TT><BR><BR>Desenha uma linha, no bitmap apontado por 
<TT><B>bmp</B></TT>, da coordenada (<TT><B>x1</B></TT>, <TT><B>y1</B></TT>) até 
a coordenada (<TT><B>x2</B></TT>, <TT><B>y2</B></TT>), utilizando a cor 
especificada por <TT><B>color</B></TT>.</P>
<P><TT><B>void hline(BITMAP *bmp, int x1, int y, int x2, int 
color);</B></TT><BR><BR>Desenha uma linha horizontal, no bitmap apontado por 
<TT><B>bmp</B></TT>, da coordenada (<TT><B>x1</B></TT>, <TT><B>y</B></TT>) até a 
coordenada (<TT><B>x2</B></TT>, <TT><B>y</B></TT>), utilizando a cor 
especificada por <TT><B>color</B></TT>.</P>
<P><TT><B>void vline(BITMAP *bmp, int x, int y1, int y2, int 
color);</B></TT><BR><BR>Desenha uma linha vertical, no bitmap apontado por 
<TT><B>bmp</B></TT>, da coordenada (<TT><B>x</B></TT>, <TT><B>y1</B></TT>) até a 
coordenada (<TT><B>x</B></TT>, <TT><B>y2</B></TT>), utilizando a cor 
especificada por <TT><B>color</B></TT>.</P><A name=video_bmp_rect>
<P><TT><B>void rect(BITMAP *bmp, int x1, int y1, int x2, int y2, int 
color);</B></TT><BR><BR>Desenha a borda de um retângulo, no bitmap apontado por 
<TT><B>bmp</B></TT>, da coordenada (<TT><B>x1</B></TT>, <TT><B>y1</B></TT>) até 
a coordenada (<TT><B>x2</B></TT>, <TT><B>y2</B></TT>), utilizando a cor 
especificada por <TT><B>color</B></TT>.</P>
<P><TT><B>void rectfill(BITMAP *bmp, int x1, int y1, int x2, int y2, int 
color);</B></TT><BR><BR>Desenha um retângulo, no bitmap apontado por 
<TT><B>bmp</B></TT>, da coordenada (<TT><B>x1</B></TT>, <TT><B>y1</B></TT>) até 
a coordenada (<TT><B>x2</B></TT>, <TT><B>y2</B></TT>), utilizando a cor 
especificada por <TT><B>color</B></TT>.</P>
<P><TT><B>void triangle(BITMAP *bmp, int x1, int y1, int x2, int y2, int x3, int 
y3, int color);</B></TT><BR><BR>Desenha um triângulo, no bitmap apontado por 
<TT><B>bmp</B></TT>, com vértices (<TT><B>x1</B></TT>, <TT><B>y1</B></TT>), 
(<TT><B>x2</B></TT>, <TT><B>y2</B></TT>) e (<TT><B>x3</B></TT>, 
<TT><B>y3</B></TT>).</P>
<P><TT><B>void polygon(BITMAP *bmp, int vertices, int *points, int 
color);</B></TT><BR><BR>Desenha um polígono, no bitmap apontado por 
<TT><B>bmp</B></TT>, com <TT><B>vertices</B></TT> vértices especificados pelo 
vetor <TT><B>points</TT></B> de pares de coordenadas (x, y), com cor 
<TT><B>color</B></TT>. Por exemplo:</P><TT>
<OL>int *pontos = { 1, 1, 2, 4, 6, 3, 5, 5 };<BR>BITMAP 
  *bmp;<BR><BR>(...)<BR><BR>bmp = create_bitmap(50, 50);<BR>polygon(bmp, 4, 
  pontos, 100);<BR><BR>(...)<BR><BR></OL></TT>
<P>irá desenhar um quadrilátero com vértices (1, 1), (2, 4), (6, 3), (5, 5) no 
bitmap <TT><B>bmp</B></TT> com cor 100.</P>
<P><TT><B>void circle(BITMAP *bmp, int x, int y, int radius, int 
color);</B></TT><BR><BR>Desenha uma circunferência, no bitmap apontado por 
<TT><B>bmp</B></TT>, com centro (<TT><B>x</B></TT>, <TT><B>y</B></TT>) e raio 
<TT><B>radius</B></TT>, utilizando a cor especificada por 
<TT><B>color</B></TT>.</P>
<P><TT><B>void circlefill(BITMAP *bmp, int x, int y, int radius, int 
color);</B></TT><BR><BR>Desenha um círculo, no bitmap apontado por 
<TT><B>bmp</B></TT>, com centro (<TT><B>x</B></TT>, <TT><B>y</B></TT>) e raio 
<TT><B>radius</B></TT>, utilizando a cor especificada por 
<TT><B>color</B></TT>.</P><A name=video_bmp_blit>
<P><TT><B>void blit(BITMAP *source, BITMAP *dest, int source_x, int source_y, 
int dest_x, int dest_y, int width, int height);</B></TT><BR><BR>Copia uma área 
retangular, de largura <TT><B>width</B></TT> e altura <TT><B>height</B></TT>, da 
coordenada (<TT><B>source_x</B></TT>, <TT><B>source_y</B></TT>) do bitmap 
apontado por <TT><B>source</B></TT> para a coordenada (<TT><B>dest_x</B></TT>, 
<TT><B>dest_y</B></TT>) do bitmap apontado por <TT><B>dest</B></TT>. <A 
name=video_bmp_draw_sprite>
<P><TT><B>void draw_sprite(BITMAP *bmp, BITMAP *sprite, int x, int 
y);</B></TT><BR><BR>Copia inteiramente o bitmap apontado por 
<TT><B>sprite</B></TT> na coordenada (<TT><B>x</B></TT>, <TT><B>y</B></TT>) do 
bitmap apontado por <TT><B>bmp</B></TT>. Equivalente a 
blit(<TT><B>sprite</B></TT>, <TT><B>bmp</B></TT>, 0, 0, x, y, 
<TT><B>sprite-&gt;w</B></TT>, <TT><B>sprite-&gt;h</B></TT>).</P>
<P>A grande diferença entre as funções <A 
href="http://equipe.nce.ufrj.br/adriano/c/apostila/allegro/docs/funcoes.html#video_bmp_blit"><TT>blit</TT></A> 
e <TT>draw_sprite</TT> é que a primeira desenha o bitmap como ele é, enquanto a 
segunda trata como transparente as cores 0 (normalmente preto, no modo 8 bits) e 
rosa claro (nos outros modos).</P>
<HR>
<A name=video_pal>
<H3>2.3. Funções de Paleta</H3>Todas as funções de desenho do Allegro usam 
parâmetros inteiros para representar cores. No modo de 256 cores, esses valores 
correspondem a índices de um vetor, onde cada elemento é uma estrutura que 
contém as intensidades de vermelho, verde e azul de cada uma das 256 cores 
possíveis. Este vetor é denominado paleta. Para declará-la, digite: <TT>
<OL>PALETTE nome_da_paleta;</OL></TT>O Allegro define algumas paletas padrões, 
que podem ser utilizadas pelo usuário para determinadas situações. São elas: 
<P><TT><B>extern PALETTE desktop_palette;</B></TT><BR><BR>Esta paleta era 
utilizada pelo Atari ST. É utilizada pelos programas de teste e exemplo do 
Allegro e é a paleta padrão utilizada pelo mesmo, caso nenhuma outra paleta seja 
setada.</P><A name=video_pal_black_palette>
<P><TT><B>extern PALETTE black_palette;</B></TT><BR><BR>Nesta paleta, todas as 
256 cores possíveis correspondem a cor preta. Esta paleta é utilizada pelas 
funcões de <I>fade</I>, e pode ser utilizada também pelo usuário em determinadas 
situações, em conjunto com a função <A 
href="http://equipe.nce.ufrj.br/adriano/c/apostila/allegro/docs/funcoes.html#video_pal_set_palette"><TT>set_palette</TT></A>.</P><A 
name=video_pal_set_palette>
<P><TT><B>void set_palette(PALETTE p);</B></TT><BR><BR>Seleciona a paleta 
especificada por <TT><B>p</B></TT> como a paleta a ser utilizada.</P>
<P><TT><B>void set_palette_range(PALETTE p, int from, int to, int 
vsync);</B></TT><BR><BR>Seleciona, da paleta especificada por <TT><B>p</B></TT>, 
os índices de <TT><B>from</B></TT> até <TT><B>to</B></TT>. Se 
<TT><B>vsync</B></TT> tiver um valor verdadeiro, o Allegro espera pelo retraço 
vertical antes de selecionar a paleta. Tem o mesmo efeito da função <A 
href="http://equipe.nce.ufrj.br/adriano/c/apostila/allegro/docs/funcoes.html#video_pal_set_palette"><TT>set_palette</TT></A>, 
com a diferença que apenas um trecho da paleta é selecionado para uso.</P>
<P><TT><B>void get_palette(PALETTE p);</B></TT><BR><BR>Guarda a paleta utilizada 
atualmente em <TT><B>p</B></TT>.</P>
<P><TT><B>void get_palette_range(PALETTE p, int from, int 
to);</B></TT><BR><BR>Guarda parte da paleta utilizada atualmente em 
<TT><B>p</B></TT>, com índices de <TT><B>from</B></TT> até 
<TT><B>to</B></TT>.</P><A name=video_pal_fade_in>
<P><TT><B>void fade_in(PALETTE p, int speed);</B></TT><BR><BR>Altera 
gradualmente as cores da paleta atual, desde a <A 
href="http://equipe.nce.ufrj.br/adriano/c/apostila/allegro/docs/funcoes.html#video_pal_black_palette"><TT>black_palette</TT></A> 
até a paleta <TT><B>p</B></TT>, com velocidade <TT><B>speed</B></TT> (1 - 
devagar, 64 - muito rápido).</P><A name=video_pal_fade_out>
<P><TT><B>void fade_out(int speed);</B></TT><BR><BR>Altera gradualmente as cores 
da plaheta atual até atingir a <A 
href="http://equipe.nce.ufrj.br/adriano/c/apostila/allegro/docs/funcoes.html#video_pal_black_palette"><TT>black_palette</TT></A>, 
com velocidade <TT><B>speed</B></TT> (1 - devagar, 64 - muito rápido).</P>
<P><TT><B>void fade_in_range(PALETTE p, int speed, int from, int 
to);</B></TT><BR><BR>Altera gradualmente as cores da paleta atual, dos índices 
de <TT><B>from</B></TT> até <TT><B>to</B></TT>, desde a <A 
href="http://equipe.nce.ufrj.br/adriano/c/apostila/allegro/docs/funcoes.html#video_pal_black_palette"><TT>black_palette</TT></A> 
até a paleta <TT><B>p</B></TT>, com velocidade <TT><B>speed</B></TT> (1 - 
devagar, 64 - muito rápido).</P>
<P><TT><B>void fade_from(PALETTE source, PALETTE dest, int 
speed);</B></TT><BR><BR>Atlera gradualmente as cores da paleta atual, desde a 
paleta <TT><B>source</B></TT> até a paleta <TT><B>dest</B></TT>, com velocidade 
<TT><B>speed</B></TT> (1 - devagar, 64 - muito rápido).</P>
<HR>
<A name=video_font>
<H3>2.4. Funções de Fonte</H3>Assim como para os bitmaps e paletas, o Allegro 
define um tipo FONT, que contém a descrição de fontes que podem ser desenhadas 
na tela. Para declarar uma fonte, digite: <TT>
<OL>FONT *nome_da_fonte;</OL></TT>
<P><TT><B>extern FONT *font;</B></TT><BR><BR>Esta fonte é utilizada como padrão 
para determinadas tarefas do Allegro, e pode ser alterada para que o Allegro 
utilize uma nova fonte nessas funções.</P><A name=video_font_text_mode>
<P><TT><B>void text_mode(int mode);</B></TT><BR><BR>Altera o modo de desenho do 
texto. Se <TT><B>mode</B></TT> for 0 (zero) ou positivo, o fundo dos caracteres 
terá a cor de código <TT><B>mode</B></TT>. Caso seja negativo, o fundo será 
transparente. O padrão é 0 (zero).</P><A name=video_font_textout>
<P><TT><B>void textout(BITMAP *bmp, FONT *f, unsigned char *s, int x, int y, int 
color);</B></TT><BR><BR>Escreve a string <TT><B>s</B></TT>, na coordenada 
(<TT><B>x</B></TT>, <TT><B>y</B></TT>) do bitmap apontado por 
<TT><B>bmp</B></TT>, utilizando a fonte apontada por <TT><B>f</B></TT> e a cor 
<TT><B>color</B></TT>. Se o valor de <TT><B>color</B></TT> for -1, a cor 
utilizada será a cor original do bitmap da fonte.</P><A 
name=video_font_textout_centre>
<P><TT><B>void textout_centre(BITMAP *bmp, FONT *f, unsigned char *s, int x, int 
y, int color);</B></TT><BR><BR>Semelhante a função <A 
href="http://equipe.nce.ufrj.br/adriano/c/apostila/allegro/docs/funcoes.html#video_font_textout"><TT>textout</TT></A>, 
porém, imprime a string <TT><B>s</B></TT> centralizada na coordenada 
especificada.</P><A name=video_font_textprintf>
<P><TT><B>void textprintf(BITMAP *bmp, FONT *f, int x, int y, int color, char 
*fmt, ...);</B></TT><BR><BR>Escreve um texto formatado (no mesmo estilo da 
função printf) no bitmap apontado por <TT><B>bmp</B></TT>, na coordenada 
(<TT><B>x</B></TT>, <TT><B>y</B></TT>), utilizando a fonte apontada por 
<TT><B>f</B></TT> e a cor <TT><B>color</B></TT>.</P><A 
name=video_font_textprintf_centre>
<P><TT><B>void textprintf_centre(BITMAP *bmp, FONT *f, int x, int y, int color, 
char *fmt, ...);</B></TT><BR><BR>Semelhante a função <A 
href="http://equipe.nce.ufrj.br/adriano/c/apostila/allegro/docs/funcoes.html#video_font_textprintf"><TT>textprintf</TT></A>, 
porém, imprime o texto formatado centralizado na coordenada 
especificada.</P><IMG alt="barra horizontal azul" hspace=5 
src="As Funções do Allegro2_files/bluebar.gif" width="100%" align=left><BR><A 
name=keyboard>
<H2>3. Funções de Teclado</H2><A name=keyboard_install_keyboard>
<P><TT><B>int install_keyboard();</B></TT><BR><BR>Inicializa o teclado para ser 
usado pelo Allegro. Deve-se chamar esta função antes de qualquer outra função de 
teclado. Após a chamada desta função, não se pode mais utilizar as funções 
padrões de acesso ao teclado (scanf, getchar, etc.). Para usar as funções 
padrões de acesso ao teclado novamente utilize a função <A 
href="http://equipe.nce.ufrj.br/adriano/c/apostila/allegro/docs/funcoes.html#keyboard_remove_keyboard"><TT>remove_keyboard</TT></A>.</P><A 
name=keyboard_remove_keyboard>
<P><TT><B>void remove_keyboard();</B></TT><BR><BR>Devolve o controle do teclado 
a BIOS. Faz o contrário da função <A 
href="http://equipe.nce.ufrj.br/adriano/c/apostila/allegro/docs/funcoes.html#keyboard_install_keyboard"><TT>install_keyboard</TT></A>. 
Normalmente, não é necessário chamar esta função, pois a função <A 
href="http://equipe.nce.ufrj.br/adriano/c/apostila/allegro/docs/funcoes.html#bas_allegro_exit"><TT>allegro_exit</TT></A> 
já o faz.</P><A name=keyboard_clear_keybuf>
<P><TT><B>void clear_keybuf();</B></TT><BR><BR>Limpa o <I>buffer</I> do teclado. 
Qualquer tecla anteriormente pressionada que ainda não tenha sido lida pela 
função <A 
href="http://equipe.nce.ufrj.br/adriano/c/apostila/allegro/docs/funcoes.html#keyboard_readkey"><TT>readkey</TT></A> 
será perdida.</P><A name=keyboard_keypressed>
<P><TT><B>int keypressed();</B></TT><BR><BR>Retorna verdadeiro caso alguma tecla 
tenha sido pressionada e esteja no <I>buffer</I> a espera da leitura. 
Equivalente a função kbhit da conio.</P><A name=keyboard_readkey>
<P><TT><B>int readkey();</B></TT><BR><BR>Retorna o próximo caractere do 
<I>buffer</I> do teclado. Se o <I>buffer</I> estiver vazio, a função espera até 
que uma tecla seja pressionada. O byte baixo do valor retornado contém o código 
ASCII do caracter, enquanto o byte alto retorna o scancode da tecla. O scancode 
não é afetado pelas teclas SHIFT, CTRL e ALT. O código ASCII é afetado 
normalmente pelas teclas SHIFT e CTRL (a tecla SHIFT altera o caso, enquanto a 
tecla CTRL retorna a posição da tecla pressionada simultaneamente). Ao 
pressionar a tecla ALT o código ASCII retornado é 0 (zero), retornando apenas o 
scancode (ainda no byte alto). Por exemplo:</P><TT>
<OL>/* Pelo codigo ASCII */<BR>if ((readkey() &amp; 0xFF) == 'd')<BR>
  <OL>printf("Voce pressionou a tecla 'd'\n");</OL><BR><BR>/* Pelo scancode 
  */<BR>if ((readkey() &gt;&gt; 8) == KEY_SPACE)<BR>
  <OL>printf("Voce pressionou a tecla Espaço\n");</OL><BR><BR>/* Pressionando 
  CTRL+[letra] */<BR>if ((readkey() &amp; 0xFF) == 3)<BR>
  <OL>printf("Voce pressionou CTRL+C\n");</OL><BR><BR>/* Pressionando 
  ALT+[letra] */<BR>if (readkey() == (KEY_X &lt;&lt; 8))<BR>
  <OL>printf("Voce pressionou ALT+X\n");</OL><BR></OL></TT>
<P><TT><B>extern volatile char key[KEY_MAX];</B></TT><BR><BR>Vetor de 
<TT><B>KEY_MAX</B></TT> posições, cada uma representando uma das teclas do 
teclado. Caso o valor de key[KEY_TECLA] seja verdadeiro, a tecla está sendo 
pressionada. Por exemplo:</P><TT>
<OL>if (key[KEY_D])<BR>
  <OL>printf("Voce pressionou a tecla 'D'\n");</OL><BR><BR>if 
  (key[KEY_SPACE])<BR>
  <OL>printf("Voce pressionou a tecla Espaço\n");</OL><BR><BR>if 
  ((key[KEY_CTRL]) &amp;&amp; (key[KEY_C]))<BR>
  <OL>printf("Voce pressionou CTRL+C\n");</OL><BR><BR>if ((key[KEY_ALT] 
  &amp;&amp; (key[KEY_X]))<BR>
  <OL>printf("Voce pressionou ALT+X\n");</OL><BR></OL></TT>
<P>Note que key[KEY_TECLA] apenas informa o estado da tecla, não espera pelo 
pressionamento da mesma.</P><IMG alt="barra horizontal azul" hspace=5 
src="As Funções do Allegro2_files/bluebar.gif" width="100%" align=left><BR><A 
name=mouse>
<H2>4. Funções de Mouse</H2><A name=mouse_install_mouse>
<P><TT><B>int install_mouse();</B></TT><BR><BR>Inicializa o mouse para ser usado 
pelo Allegro. É necessário chamar esta função antes de qualquer outra função de 
mouse. Retorna -1 se ocorrer algum erro; caso contrário, retorna o número de 
botões do mouse.</P>
<P><TT><B>void remove_mouse();</B></TT><BR><BR>Remove o controle do Allegro 
sobre o mouse. Normalmente, não é necessário chamar esta função, pois a função 
<A 
href="http://equipe.nce.ufrj.br/adriano/c/apostila/allegro/docs/funcoes.html#bas_allegro_exit"><TT>allegro_exit</TT></A> 
já o faz.</P><A name=mouse_mouse_x_y>
<P><TT><B>extern volatile int mouse_x;</B></TT><BR><TT><B>extern volatile int 
mouse_y;</B></TT><BR><BR>Guardam os valores da posição x e y do cursor do 
mouse.</P><A name=mouse_mouse_b>
<P><TT><B>extern volatile int mouse_b;</B></TT><BR><BR>Guarda o estado atual do 
pressionamento dos botões do mouse. O bit 0 de <TT><B>mouse_b</B></TT> guarda o 
estado do botão esquerdo, o bit 1 o do botão esquerdo, e o bit 2 o do botão do 
meio.</P><TT>
<OL>if (mouse_b &amp; 1)<BR>
  <OL>printf("Botão esquerdo do mouse pressionado\n");</OL><BR><BR>if (!(mouse_b 
  &amp; 2))<BR>
  <OL>printf("Botão direito do mouse não pressionado\n");</OL><BR><BR>if 
  (mouse_b &amp; 4)<BR>
  <OL>printf("Botão do meio do mouse pressionado\n");</OL><BR></OL></TT>
<P><TT><B>void set_mouse_range(int x1, int y1, int x2, int 
y2);</B></TT><BR><BR>Define a área onde o ponteiro do mouse pode se locomover na 
tela. A área é definida pelo retângulo de coordenada superior esquerda 
(<TT><B>x1</B></TT>, <TT><B>y1</B></TT>) e coordenada inferior direita 
(<TT><B>x2</B></TT>, <TT><B>y2</B></TT>).</P>
<P><TT><B>void position_mouse(int x, int y);</B></TT><BR><BR>Move o ponteiro do 
mouse para a coordenada (<TT><B>x</B></TT>, <TT><B>y</B></TT>).</P><A 
name=mouse_show_mouse>
<P><TT><B>void show_mouse(BITMAP *bmp);</B></TT><BR><BR>Mostra o ponteiro do 
mouse no bitmap apontado por <TT><B>bmp</B></TT>. Funciona apenas se o <A 
href="http://equipe.nce.ufrj.br/adriano/c/apostila/allegro/docs/funcoes.html#outras_timer">timer</A> 
estiver instalado. Para esconder o ponteiro do mouse, passe o valor 
<TT><B>NULL</B></TT> como argumento. Não é recomendável desenhar na tela 
enquanto o ponteiro do mouse estiver visível, pois isto pode gerar manchas 
provocadas pelo rastro do mouse. Também não é uma boa idéia esconder o mouse, 
desenhar na tela e exibir o mouse novamente, pois isto faz com que o mouse fique 
"piscando" na tela. O ideal é que sejam utilizadas técnicas como o <A 
href="http://equipe.nce.ufrj.br/adriano/c/apostila/allegro/docs/tecnicas.html#double_buffering">double 
buffering</A>.</P><IMG alt="barra horizontal azul" hspace=5 
src="As Funções do Allegro2_files/bluebar.gif" width="100%" align=left><BR><A 
name=sound>
<H2>5. Funções de Som</H2><A name=sound_install_sound>
<P><TT><B>int install_sound(int digi_card, int midi_card, char 
*cfg_path);</B></TT><BR><BR>Inicializa o módulo de som para ser usado com o 
Allegro. Os parâmetros <TT><B>digi_card</B></TT> e <TT><B>midi_card</B></TT> 
referem-se, respectivamente, aos controladores de som digital e MIDI.</P>
<P>O valor de <TT><B>digi_card</B></TT> deve ser um dos abaixo:</P>
<CENTER>
<TABLE cols=2 width="70%" border=1 ROWS="10">
  <TBODY>
  <TR>
    <TD>DIGI_AUTODETECT</TD>
    <TD>instrui o Allegro a escolher o driver de som</TD></TR>
  <TR>
    <TD>DIGI_NONE</TD>
    <TD>sem som digital</TD></TR>
  <TR>
    <TD>DIGI_SB</TD>
    <TD>auto-detecta placas do tipo Sound Blaster</TD></TR>
  <TR>
    <TD>DIGI_SB10</TD>
    <TD>Sound Blaster 1.0 (8 bit mono)</TD></TR>
  <TR>
    <TD>DIGI_SB15</TD>
    <TD>Sound Blaster 1.5 (8 bit mono)</TD></TR>
  <TR>
    <TD>DIGI_SB20</TD>
    <TD>Sound Blaster 2.0 (8 bit mono)</TD></TR>
  <TR>
    <TD>DIGI_SBPRO</TD>
    <TD>Sound Blaster Pro (8 bit stereo)</TD></TR>
  <TR>
    <TD>DIGI_SB16</TD>
    <TD>Sound Blaster 16 (16 bit stereo)</TD></TR>
  <TR>
    <TD>DIGI_AUDIODRIVE</TD>
    <TD>ESS AudioDrive</TD></TR>
  <TR>
    <TD>DIGI_SOUNDSCAPE</TD>
    <TD>Ensoniq Soundscape</TD></TR></TBODY></TABLE></CENTER>
<P>O valor de <TT><B>midi_card</B></TT> deve ser um dos abaixo:</P>
<CENTER>
<TABLE cols=2 width="70%" border=1 ROWS="10">
  <TBODY>
  <TR>
    <TD>MIDI_AUTODETECT</TD>
    <TD>instrui o Allegro a escolher o driver de MIDI</TD></TR>
  <TR>
    <TD>MIDI_NONE</TD>
    <TD>sem som MIDI</TD></TR>
  <TR>
    <TD>MIDI_ADLIB</TD>
    <TD>auto-detecta sintetizadores do tipo Adlib ou Sound Blaster FM</TD></TR>
  <TR>
    <TD>MIDI_OPL2</TD>
    <TD>sintetizador OPL2 (mono, usado em Adlib e Sound Blaster)</TD></TR>
  <TR>
    <TD>MIDI_2XOPL2</TD>
    <TD>sintetizador OPL2 dual (stereo, usado em Sound Blaster Pro-I)</TD></TR>
  <TR>
    <TD>MIDI_OPL3</TD>
    <TD>sintetizador OPL3 (stereo, usado em Sound Blaster Pro-II e 
acima)</TD></TR>
  <TR>
    <TD>MIDI_SB_OUT</TD>
    <TD>interface MIDI Sound Blaster</TD></TR>
  <TR>
    <TD>MIDI_MPU</TD>
    <TD>interface MIDI MPU-401</TD></TR>
  <TR>
    <TD>MIDI_DIGMID</TD>
    <TD>sample-based software wavetable player</TD></TR>
  <TR>
    <TD>MIDI_AWE32</TD>
    <TD>AWE32 (EMU8000 chip)</TD></TR></TBODY></TABLE></CENTER>
<P>O parâmetro <TT><B>cfg_path</B></TT> existe apenas para compatibilidade com 
versões anteriores do Allegro. Ignore-o passando o valor 
<TT><B>NULL</B></TT>.</P>
<P><TT><B>void remove_sound();</B></TT><BR><BR>Remove o módulo de som. 
Normalmente não é necessário chamar esta função, pois a função <A 
href="http://equipe.nce.ufrj.br/adriano/c/apostila/allegro/docs/funcoes.html#bas_allegro_exit"><TT>allegro_exit</TT></A> 
já o faz.</P><A name=sound_load_midi>
<P><TT><B>MIDI *load_midi(char *filename);</B></TT><BR><BR>Carrega um arquivo 
MIDI, retornando um ponteiro para uma estrutura <TT><B>MIDI</B></TT>. Caso 
ocorra um erro, o valor <TT><B>NULL</B></TT> será retornado.</P><A 
name=sound_play_midi>
<P><TT><B>int play_midi(MIDI *midi, int loop);</B></TT><BR><BR>Toca a MIDI 
especificada por <TT><B>midi</B></TT>, parando de tocar qualquer música que 
estivesse sendo tocada anteriormente. Se a flag <TT><B>loop</B></TT> estiver 
setada, a música será tocada até que a função seja novamente chamada para tocar 
outra música, ou a função <A 
href="http://equipe.nce.ufrj.br/adriano/c/apostila/allegro/docs/funcoes.html#sound_stop_midi"><TT>stop_midi</TT></A> 
seja chamada. Caso a flag <TT><B>loop</B></TT> não esteja setada, a música irá 
parar de tocar ao alcançar o final do MIDI. Retorna um valor diferente de zero 
se um erro ocorrer.</P><A name=sound_stop_midi>
<P><TT><B>void stop_midi();</B></TT><BR><BR>Faz parar de tocar qualquer música 
que esteja sendo tocada. Tem o mesmo efeito da instrução <TT><B>play_midi(NULL, 
FALSE)</B></TT>.</P><A name=sound_load_sample>
<P><TT><B>SAMPLE *load_sample(char *filename);</B></TT><BR><BR>Carrega um 
arquivo sample, retornando um ponteiro para uma estrutura 
<TT><B>SAMPLE</B></TT>. Caso ocorra um erro, o valor <TT><B>NULL</B></TT> será 
retornado. Aceita arquivos do tipo WAV (mono e stereo) e VOC (mono) em formato 8 
e 16 bits.</P><A name=sound_play_sample>
<P><TT><B>int play_sample(SAMPLE *spl, int vol, int pam, int freq, int 
loop);</B></TT><BR><BR>Inicializa o sample especificado por <TT><B>spl</B></TT> 
utilizando determinados argumentos. O argumento <TT><B>vol</B></TT> determina o 
volume (valores de 0 até 255), o argumento <TT><B>pan</B></TT> determina o 
balanço (valores de 0 até 255), o argumento <TT><B>freq</B></TT> determina a 
frequência com que o sample é tocado (o valor 1000 faz com que o sample seja 
tocado na mesma frequência que foi gravado; o valor 2000 é o dobro da 
frequência, etc.) e o argumento <TT><B>loop</B></TT> informa se o Allegro deve 
repetir o sample infinitamente ou não.</P><A name=sound_stop_sample>
<P><TT><B>void stop_sample(SAMPLE *spl);</B></TT><BR><BR>Faz parar de tocar o 
sample especificado por <TT><B>spl</B></TT>. É necessário chamar esta função 
caso o sample tenha sido incializado com a flag <TT><B>loop</B></TT> 
setada.</P><IMG alt="barra horizontal azul" hspace=5 
src="As Funções do Allegro2_files/bluebar.gif" width="100%" align=left><BR><A 
name=outras>
<H2>6. Outras Funções</H2><A name=outras_timer>
<H3>6.1. Funções de Timer</H3><A name=outras_timer_install_timer>
<P><TT><B>int install_timer();</B></TT><BR><BR>Inicializa o temporizador do 
Allegro. É necessário chamar esta função antes de usar qualquer função de timer, 
bem como antes de mostrar o ponteiro do mouse ou tocar uma MIDI.</P>
<P><TT><B>void remove_timer();</B></TT><BR><BR>Remove o temporizador do Allegro. 
Normalmente, não é necessário chamar esta função, pois a função <A 
href="http://equipe.nce.ufrj.br/adriano/c/apostila/allegro/docs/funcoes.html#bas_allegro_exit"><TT>allegro_exit</TT></A> 
já o faz.</P>
<P><TT><B>int install_int(void (*proc)(), int speed);</B></TT><BR><BR>Inicializa 
um temporizador para que, a cada intervalo de <TT><B>speed</B></TT> 
milisegundos, a função <TT><B>proc</B></TT> seja chamada. Caso a função 
install_int seja chamada antes da inicialização do temporizador do Allegro, a 
função <A 
href="http://equipe.nce.ufrj.br/adriano/c/apostila/allegro/docs/funcoes.html#outras_timer_install_timer"><TT>install_timer</TT></A> 
será automaticamente chamada.</P>
<P><TT><B>void remove_int(void (*proc)());</B></TT><BR><BR>Remove o temporizador 
que chama a função <TT><B>proc</B></TT>. A remoção dos temporizadores é feita 
automaticamente pela função <A 
href="http://equipe.nce.ufrj.br/adriano/c/apostila/allegro/docs/funcoes.html#bas_allegro_exit"><TT>allegro_exit</TT></A>.</P>
<P><TT><B>LOCK_VARIABLE(<I>variavel</I>)<BR>LOCK_FUNCTION(<I>funcao</I>)<BR>END_OF_FUNCTION(<I>funcao</I>)</B></TT><BR><BR>Essas 
três macros são necessárias quando utiliza-se temporizadores. As macros 
<TT><B>LOCK_VARIABLE</B></TT> e <TT><B>LOCK_FUNCTION</B></TT> bloqueiam a área 
de memória ultilizada pela variável ou função, enquanto a macro 
<TT><B>END_OF_FUNCTION</B></TT> determina o final de uma função dentro do 
programa. Por exemplo:</P><TT>
<OL>int x;<BR><BR>(...)<BR><BR>int aumenta_x()<BR>{<BR>
  <OL>x++;</OL><BR>}<BR>END_OF_FUNCTION(aumenta_x);<BR><BR>int main()<BR>{<BR>
  <OL><BR>(...)<BR><BR>/*
    <OL>Bloqueia a variavel x e a funcao aumenta_x<BR>e instala um 
      temporizador que chamara a<BR>funcao aumenta_x a cada 0,2 segundo 
      (200<BR>milisegundos). 
    </OL>*/<BR>LOCK_VARIABLE(x);<BR>LOCK_FUNCTION(aumenta_x);<BR>install_int(aumenta_x, 
    200);<BR><BR>(...)<BR><BR></OL>}<BR></OL></TT>
<P><TT><B>void rest(long time);</B></TT><BR><BR>Provoca uma pausa de 
<TT><B>time</B></TT> milisegundos no programa.</P>
<HR>
<A name=outras_datafile>
<H3>6.2. Funções de DataFile</H3>
<P>DataFile é um tipo especial de arquivo, com extensão .dat, e que pode 
armazenar diversos tipos de arquivos, como BitMaps, MIDIs, fontes, paletas, que 
podem ser carregados e utilizados durante a execução do programa.</P>
<P>Para criar um arquivo DataFile existe um utilitário chamado <I>Grabber</I>, 
que se encontra no diretório <TT><B>tools</B></TT>, dentro do diretório 
principal do Allegro. O programa possui uma interface que facilita a confecção 
do arquivo DataFile.</P>
<P>Para acessar um arquivo DataFile num programa, utiliza-se o tipo 
<TT><B>DATAFILE</B></TT>, da seguinte maneira:</P><TT><B>
<OL>DATAFILE *dat;</OL></B></TT>
<P>Depois de determinar um ponteiro para o arquivo DataFile, pode-se abri-lo 
utilizando a função <A 
href="http://equipe.nce.ufrj.br/adriano/c/apostila/allegro/docs/funcoes.html#outras_datafile_load_datafile"><TT>load_datafile</TT></A>, 
descrita abaixo:</P><A name=#outras_datafile_load_datafile>
<P><TT><B>DATAFILE *load_datafile(const char *filename);</B></TT><BR><BR>Abre o 
arquivo de nome <TT><B>filename</B></TT> como um arquivo datafile, preparando-o 
para a leitura de seus dados. Retorna <TT><B>NULL</B></TT> caso ocorra algum 
erro.</P>
<HR>
<A name=#outras_config>
<H3>6.3. Funções de Arquivos de Configuração</H3><TT><B>void 
set_config_file(const char *filename);</B></TT><BR><BR>Instrui o Allegro a 
utilizar o arquivo <TT><B>filename</B></TT> para as futuras chamadas a outras 
funções de arquivos de configuração. Caso as outras funções sejam chamadas antes 
da função set_config_file, o Allegro utiliza o arquivo 
<TT><B>allegro.cfg</B></TT> do diretório atual como o arquivo de configuração a 
ser lido.
<P></P><A name=outras_config_set_config_string>
<P><TT><B>void set_config_string(const char *section, const char *name, const 
char *val);</B></TT><BR><BR>Escreve uma string no arquivo de configuração atual 
na chave <TT><B>name</B></TT> da seção <TT><B>section</B></TT>. Caso 
<TT><B>val</B></TT> seja <TT><B>NULL</B></TT>, a chave é removida do arquivo. 
Caso <TT><B>section</B></TT> seja <TT><B>NULL</B></TT>, a chave é escrita na 
raiz do arquivo de configuração. Os dados são escritos no arquivo ao chamar a 
função <A 
href="http://equipe.nce.ufrj.br/adriano/c/apostila/allegro/docs/funcoes.html#bas_allegro_exit"><TT>allegro_exit</TT></A>.</P>
<P>As linhas iniciadas com um '#' não são lidas ou escritas no arquivo de 
configuração, sendo tratadas como comentários.</P><A 
name=outras_config_set_config_id>
<P><TT><B>void set_config_id(const char *section, const char *name, int 
val);</B></TT><BR><BR>Faz o mesmo que a função <A 
href="http://equipe.nce.ufrj.br/adriano/c/apostila/allegro/docs/funcoes.html#outras_config_set_config_string"><TT>set_config_string</TT></A>, 
exceto pelo fato de escrever um ID no arquivo, ao invés de uma string. Para cada 
valor de <TT><B>val</B></TT> existe um ID de 4 letras correspondente. Isto é 
útil para guardar informações sobre placas de vídeo e som nos arquivos de 
configuração.</P>
<P><TT><B>void set_config_int(const char *section, const char *name, int 
val);</B></TT><BR><TT><B>void set_config_hex(const char *section, const char 
*name, int val);</B></TT><BR><TT><B>void set_config_float(const char *section, 
const char *name, float val);</B></TT><BR><BR>Fazem o mesmo que a função <A 
href="http://equipe.nce.ufrj.br/adriano/c/apostila/allegro/docs/funcoes.html#outras_config_set_config_string"><TT>set_config_string</TT></A>, 
exceto pelo fato de escreverem, respectivamente, números inteiros, hexadecimais 
e de ponto flutuante.</P><A name=outras_config_get_config_string>
<P><TT><B>const char *get_config_string(const char *section, const char *name, 
const char *def);</B></TT><BR><BR>Lê uma string do arquivo de configuração atual 
da chave <TT><B>name</B></TT> da seção <TT><B>section</B></TT>. Caso 
<TT><B>section</B></TT> seja <TT><B>NULL</B></TT>, a chave é lida da raiz do 
arquivo de configuração. Caso a chave não seja encontrada, o valor de 
<TT><B>def</B></TT> é retornado.</P>
<P><TT><B>int get_config_id(const char *section, const char *name, int 
def);</B></TT><BR><BR>Lê uma ID (veja em <A 
href="http://equipe.nce.ufrj.br/adriano/c/apostila/allegro/docs/funcoes.html#outras_config_set_config_id"><TT>set_config_id</TT></A>) 
do arquivo de configuração atual (mais detalhes em <A 
href="http://equipe.nce.ufrj.br/adriano/c/apostila/allegro/docs/funcoes.html#outras_config_get_config_string"><TT>get_config_string</TT></A>).</P>
<P><TT><B>int get_config_int(const char *section, const char *name, int 
def);</B></TT><BR><TT><B>int get_config_hex(const char *section, const char 
*name, int def);</B></TT><BR><TT><B>float get_config_float(const char *section, 
const char *name, float def);</B></TT><BR><BR>Lêem, respectivamente, um número 
inteiro, hexadecimal e de ponto flutuante, do arquivo de configuração atual 
(mais detalhes em <A 
href="http://equipe.nce.ufrj.br/adriano/c/apostila/allegro/docs/funcoes.html#outras_config_get_config_string"><TT>get_config_string</TT></A>).</P><IMG 
alt="barra horizontal azul" hspace=5 
src="As Funções do Allegro2_files/bluebar.gif" width="100%" align=left><BR>
<P>
<CENTER><A 
href="http://equipe.nce.ufrj.br/adriano/c/apostila/allegro/docs/allegro.html#indice"><IMG 
height=30 hspace=5 src="As Funções do Allegro2_files/return.gif" width=30 
align=center></A> <A 
href="http://equipe.nce.ufrj.br/adriano/c/apostila/allegro/docs/allegro.html#indice">Índice 
Geral do Allegro</A> </CENTER>
<P></P></BODY></HTML>
