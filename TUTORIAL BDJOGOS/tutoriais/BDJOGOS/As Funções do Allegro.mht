From: <Salvo pelo Microsoft Internet Explorer 7>
Subject: =?Windows-1252?Q?As_Fun=E7=F5es_do_Allegro?=
Date: Mon, 23 Mar 2009 15:54:10 -0300
MIME-Version: 1.0
Content-Type: multipart/related;
	type="text/html";
	boundary="----=_NextPart_000_0000_01C9ABCF.9AFEF570"
X-MimeOLE: Produced By Microsoft MimeOLE V6.00.2900.5512

This is a multi-part message in MIME format.

------=_NextPart_000_0000_01C9ABCF.9AFEF570
Content-Type: text/html;
	charset="iso-8859-1"
Content-Transfer-Encoding: quoted-printable
Content-Location: http://equipe.nce.ufrj.br/adriano/c/apostila/allegro/docs/funcoes.html

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML><HEAD><TITLE>As Fun=E7=F5es do Allegro</TITLE>
<META http-equiv=3DCONTENT-TYPE content=3D"text/html; =
charset=3Diso-8859-1">
<META content=3D"MSHTML 6.00.5730.13" name=3DGENERATOR></HEAD>
<BODY>
<TABLE>
  <TBODY>
  <TR>
    <TD><IMG alt=3D"minerva ufrj" hspace=3D5=20
      src=3D"http://equipe.nce.ufrj.br/adriano/figuras/min_peq.gif" =
width=3D80></TD>
    <TD>
      <H3>As Fun=E7=F5es do Allegro</H3></TD></TR></TBODY></TABLE><IMG=20
alt=3D"barra horizontal azul" hspace=3D5=20
src=3D"http://equipe.nce.ufrj.br/adriano/figuras/bluebar.gif" =
width=3D"100%"=20
align=3Dleft><BR>=A92002 - Luis Menasch=E9 Schechter<BR><BR><I>Powered =
by vi</I>
<P></P>
<OL>
  <LI><A=20
  =
href=3D"http://equipe.nce.ufrj.br/adriano/c/apostila/allegro/docs/funcoes=
.html#bas">Fun=E7=F5es=20
  B=E1sicas</A>=20
  <LI><A=20
  =
href=3D"http://equipe.nce.ufrj.br/adriano/c/apostila/allegro/docs/funcoes=
.html#video">Fun=E7=F5es=20
  de V=EDdeo</A>=20
  <OL>
    <LI><A=20
    =
href=3D"http://equipe.nce.ufrj.br/adriano/c/apostila/allegro/docs/funcoes=
.html#video_bas">Fun=E7=F5es=20
    B=E1sicas de V=EDdeo</A>=20
    <LI><A=20
    =
href=3D"http://equipe.nce.ufrj.br/adriano/c/apostila/allegro/docs/funcoes=
.html#video_bmp">Fun=E7=F5es=20
    de Bitmaps</A>=20
    <LI><A=20
    =
href=3D"http://equipe.nce.ufrj.br/adriano/c/apostila/allegro/docs/funcoes=
.html#video_pal">Fun=E7=F5es=20
    de Paleta</A>=20
    <LI><A=20
    =
href=3D"http://equipe.nce.ufrj.br/adriano/c/apostila/allegro/docs/funcoes=
.html#video_font">Fun=E7=F5es=20
    de Fonte</A> </LI></OL>
  <LI><A=20
  =
href=3D"http://equipe.nce.ufrj.br/adriano/c/apostila/allegro/docs/funcoes=
.html#keyboard">Fun=E7=F5es=20
  de Teclado</A>=20
  <LI><A=20
  =
href=3D"http://equipe.nce.ufrj.br/adriano/c/apostila/allegro/docs/funcoes=
.html#mouse">Fun=E7=F5es=20
  de Mouse</A>=20
  <LI><A=20
  =
href=3D"http://equipe.nce.ufrj.br/adriano/c/apostila/allegro/docs/funcoes=
.html#sound">Fun=E7=F5es=20
  de Som</A>=20
  <LI><A=20
  =
href=3D"http://equipe.nce.ufrj.br/adriano/c/apostila/allegro/docs/funcoes=
.html#outras">Outras=20
  Fun=E7=F5es</A>=20
  <OL>
    <LI><A=20
    =
href=3D"http://equipe.nce.ufrj.br/adriano/c/apostila/allegro/docs/funcoes=
.html#outras_timer">Fun=E7=F5es=20
    de Timer</A>=20
    <LI><A=20
    =
href=3D"http://equipe.nce.ufrj.br/adriano/c/apostila/allegro/docs/funcoes=
.html#outras_datafile">Fun=E7=F5es=20
    de DataFile</A>=20
    <LI><A=20
    =
href=3D"http://equipe.nce.ufrj.br/adriano/c/apostila/allegro/docs/funcoes=
.html#outras_config">Fun=E7=F5es=20
    de Arquivos de Configura=E7=E3o</A> </LI></OL></LI></OL><IMG=20
alt=3D"barra horizontal azul" hspace=3D5=20
src=3D"http://equipe.nce.ufrj.br/adriano/figuras/bluebar.gif" =
width=3D"100%"=20
align=3Dleft><BR><A name=3Dbas>
<H2>1. Fun=E7=F5es B=E1sicas</H2><A name=3Dbas_allegro_init>
<P><TT><B>int allegro_init();</B></TT><BR><BR>Inicializa a biblioteca =
Allegro.=20
N=E3o faz muita coisa a n=E3o ser inicializar algumas vari=E1veis =
globais e reservar=20
mem=F3ria. Retorna zero em caso de sucesso (na verdade, n=E3o =E9 =
necess=E1rio checar se=20
a fun=E7=E3o foi bem sucedida, pois, ao ser usada no in=EDcio do =
programa, como =E9=20
recomendada, ela nunca falha). Deve ser a primeira fun=E7=E3o do Allegro =
a ser=20
chamada.</P><A name=3Dbas_allegro_exit>
<P><TT><B>void allegro_exit();</B></TT><BR><BR>Fecha o Allegro. Isto =
inclui=20
retornar ao modo texto e remover qualquer rotina de mouse, teclado ou=20
temporizador que tenha sido instalada. N=E3o h=E1 necessidade (embora =
seja=20
recomend=E1vel) de chamar explicitamente essa fun=E7=E3o pois, =
normalmente, isto =E9=20
feito automaticamente quando o programa termina.</P><IMG=20
alt=3D"barra horizontal azul" hspace=3D5=20
src=3D"http://equipe.nce.ufrj.br/adriano/figuras/bluebar.gif" =
width=3D"100%"=20
align=3Dleft><BR><A name=3Dvideo>
<H2>2. Fun=E7=F5es de V=EDdeo</H2><A name=3Dvideo_bas>
<H3>2.1. Fun=E7=F5es B=E1sicas de V=EDdeo</H3><A =
name=3Dvideo_bas_set_color_depth>
<P><TT><B>void set_color_depth(int depth);</B></TT><BR><BR>Esta =
fun=E7=E3o configura=20
o n=FAmero de bits de cores (determinado pelo par=E2metro =
<TT><B>depth</B></TT>) com=20
que os gr=E1ficos ser=E3o exibidos. Os poss=EDveis valores para =
<TT><B>depth</B></TT>=20
s=E3o 8, 15, 16, 24 e 32. Esta fun=E7=E3o deve ser chamada sempre =
<B>ANTES</B> da=20
fun=E7=E3o <A=20
href=3D"http://equipe.nce.ufrj.br/adriano/c/apostila/allegro/docs/funcoes=
.html#video_bas_set_gfx_mode"><TT>set_gfx_mode</TT></A>.</P><A=20
name=3Dvideo_bas_set_gfx_mode>
<P><TT><B>int set_gfx_mode(int card, int w, int h, int v_w, int=20
v_h);</B></TT><BR><BR>Instrui o Allegro a mudar para o modo gr=E1fico. O =
par=E2metro=20
<TT><B>card</B></TT> deve ser um dos seguintes valores:<BR><BR></P>
<CENTER>
<TABLE cols=3D2 width=3D"70%" border=3D1 ROWS=3D"10">
  <TBODY>
  <TR>
    <TD width=3D"35%">GFX_TEXT</TD>
    <TD>retorna para o modo texto</TD></TR>
  <TR>
    <TD width=3D"35%">GFX_AUTODETECT</TD>
    <TD>faz com que o Allegro escolha o driver gr=E1fico mais apropriado =

      (normalmente tem problemas com placas de v=EDdeo mais =
recentes)</TD></TR>
  <TR>
    <TD width=3D"35%">GFX_VGA</TD>
    <TD>modo VGA (320x200, 320x100, 160x120, 80x80)</TD></TR>
  <TR>
    <TD width=3D"35%">GFX_MODEX</TD>
    <TD>uma vers=E3o planar do modo VGA (tweaked)</TD></TR>
  <TR>
    <TD width=3D"35%">GFX_VESA1</TD>
    <TD>usa o driver VESA 1.x</TD></TR>
  <TR>
    <TD width=3D"35%">GFX_VESA2B</TD>
    <TD>usa o driver VBE 2.0 em modo banked</TD></TR>
  <TR>
    <TD width=3D"35%">GFX_VESA2L</TD>
    <TD>usa o driver VBE 2.0 com framebuffer linear</TD></TR>
  <TR>
    <TD width=3D"35%">GFX_VESA3</TD>
    <TD>usa o driver VBE 3.0</TD></TR>
  <TR>
    <TD width=3D"35%">GFX_VBEAF</TD>
    <TD>usa o acelerador de hardware API VBE/AF</TD></TR>
  <TR>
    <TD width=3D"35%">GFX_XTENDED</TD>
    <TD>usa o driver 640x480 =
unchained</TD></TR></TBODY></TABLE></CENTER><BR>
<P>Os par=E2metros <TT><B>w</B></TT> e <TT><B>h</B></TT> informam o =
numero de=20
pixels existentes, respectivamente, em uma linha e em uma coluna do =
v=EDdeo. Ex:=20
w=3D800 e h=3D600.</P>
<P>Os par=E2metros <TT><B>v_w</B></TT> e <TT><B>v_h</B></TT> determinam =
o tamanho=20
da tela virtual, ou seja, o tamanho de uma pseudo-tela da qual pode-se=20
visualizar apenas um peda=E7o (determinado pelos par=E2metros =
<TT><B>w</B></TT> e=20
<TT><B>h</B></TT>). Para manipular telas virtuais, o Allegro oferece uma =
s=E9rie=20
de fun=E7=F5es de rolamento da tela. Por=E9m, n=E3o as abordaremos. Para =
desabilitar=20
este recurso, atribua 0 (zero) a ambos os par=E2metros.</P>
<P>O valor retornado por esta fun=E7=E3o ser=E1 menor do que 0 (zero) =
se, e somente=20
se, um erro ocorrer. =C9 interessante conferir o valor retornado por =
esta fun=E7=E3o,=20
de modo a escolher o driver de v=EDdeo adequado, caso o selecionado =
n=E3o funcione.=20
Por exemplo:</P><TT>
<OL>#define VIDEO_CARD GFX_VESA1<BR>#define TAM_X 800<BR>#define TAM_Y=20
  600<BR>#define ALT_TAM_X 640<BR>#define ALT_TAM_Y =
480<BR><BR>(...)<BR><BR>if=20
  (set_gfx_mode(VIDEO_CARD, TAM_X, TAM_Y, 0, 0) &lt; 0) {<BR>
  <OL>if (set_gfx_mode(GFX_AUTODETECT, ALT_TAM_X, ALT_TAM_Y, 0, 0) &lt; =
0)=20
    {<BR>
    <OL>/* Mensagem de erro. =
*/<BR><BR>(...)<BR></OL><BR>}</OL><BR>}<BR></OL></TT>
<HR>
<A name=3Dvideo_bmp>
<H3>2.2. Fun=E7=F5es de Bitmaps</H3>O Allegro trata todos os gr=E1ficos =
que podem ser=20
exibidos na tela ou carregados na mem=F3ria como <U>bitmaps</U>. =
<U>Bitmaps</U>=20
s=E3o matrizes de pixels, em que cada valor indica uma cor. Para =
declarar um=20
bitmap, digite: <TT>
<OL>BITMAP *nome_do_bitmap;</OL></TT><A name=3Dvideo_bmp_screen>
<P><TT><B>extern BITMAP *screen;</B></TT><BR><BR>Para facilitar o uso de =
suas=20
fun=E7=F5es de manipula=E7=E3o de bitmaps, o Allegro trata a tela =
tamb=E9m como um bitmap,=20
que =E9 definido no arquivo <TT>allegro.h</TT> como <TT>screen</TT>.</P>
<P>Assim, nas fun=E7=F5es de manipula=E7=E3o de bitmaps abaixo, sempre =
que desejarmos=20
apresentar diretamente na tela algum gr=E1fico, passaremos como =
argumento da=20
fun=E7=E3o a vari=E1vel <TT>screen</TT>.</P><A =
name=3Dvideo_bmp_create_bitmap>
<P><TT><B>BITMAP *create_bitmap(int width, int =
height);</B></TT><BR><BR>Cria um=20
bitmap na mem=F3ria com largura <TT><B>width</B></TT> e altura=20
<TT><B>height</B></TT>. O valor retornado =E9 o do endere=E7o da =E1rea =
de mem=F3ria=20
onde foi alocado o espa=E7o; assim, caso a fun=E7=E3o retorne =
<TT><B>NULL</B></TT>,=20
significa que n=E3o foi poss=EDvel alocar a mem=F3ria necess=E1ria para =
armazenar o=20
bitmap com as dimens=F5es requisitadas.</P>
<P>=C9 importante notar que a fun=E7=E3o apenas aloca o espa=E7o, sem =
"limp=E1-lo", e, com=20
isso, =E9 necess=E1rio usar a fun=E7=E3o <A=20
href=3D"http://equipe.nce.ufrj.br/adriano/c/apostila/allegro/docs/funcoes=
.html#video_bmp_clear"><TT>clear</TT></A>=20
ou <A=20
href=3D"http://equipe.nce.ufrj.br/adriano/c/apostila/allegro/docs/funcoes=
.html#video_bmp_clear_to_color"><TT>clear_to_color</TT></A>,=20
mencionadas adiante.</P><A name=3Dvideo_bmp_destroy_bitmap>
<P><TT><B>void destroy_bitmap(BITMAP *bitmap);</B></TT><BR><BR>Destr=F3i =
o bitmap=20
apontado por <TT><B>bitmap</B></TT>, liberando a mem=F3ria ocupada por =
este.</P><A=20
name=3Dvideo_bmp_load_bitmap>
<P><TT><B>BITMAP *load_bitmap(char *filename, PALETTE=20
pal);</B></TT><BR><BR>Carrega um bitmap de um arquivo, cujo nome =E9=20
<TT><B>filename</B></TT>, e carrega a paleta por ele usada no endere=E7o =
apontado=20
por <TT><B>pal</B></TT>. O tipo do arquivo (BMP, LBM, PCX, TGA) =E9 =
informado=20
atrav=E9s da extens=E3o do mesmo. Deve-se destruir o bitmap ap=F3s o uso =
com a fun=E7=E3o=20
<A=20
href=3D"http://equipe.nce.ufrj.br/adriano/c/apostila/allegro/docs/funcoes=
.html#video_bmp_destroy_bitmap"><TT>destroy_bitmap</TT></A>.=20
A fun=E7=E3o retorna um NULL se houver algum erro no carregamento do =
arquivo.</P>
<P><TT><B>int save_bitmap(char *filename, BITMAP *bmp, PALETTE=20
pal);</B></TT><BR><BR>Salva o bitmap apontado por <TT><B>bmp</B></TT>, =
com a=20
paleta apontada por <TT><B>pal</B></TT>, no arquivo de nome=20
<TT><B>filename</B></TT>. O tipo do arquivo (BMP, LBM, PCX, TGA) =E9 =
informado=20
atrav=E9s da extens=E3o do mesmo. A fun=E7=E3o retorna um n=FAmero =
diferente de zero caso=20
ocorra algum erro.</P><A name=3Dvideo_bmp_clear>
<P><TT><B>void clear(BITMAP *bitmap);</B></TT><BR><BR>Limpa o bitmap =
apontado=20
por <TT><B>bitmap</B></TT> para a cor 0 (zero).</P><A=20
name=3Dvideo_bmp_clear_to_color>
<P><TT><B>void clear_to_color(BITMAP *bitmap, int =
color);</B></TT><BR><BR>Limpa=20
o bitmap apontado por <TT><B>bitmap</B></TT> para a cor especificada por =

<TT><B>color</B></TT>.</P>
<P><TT><B>void putpixel(BITMAP *bmp, int x, int y, int=20
color);</B></TT><BR><BR>Desenha um ponto, no bitmap apontado por=20
<TT><B>bmp</B></TT>, na coordenada (x, y), utilizando a cor especificada =
por=20
<TT><B>color</B></TT>.</P>
<P><TT><B>int getpixel(BITMAP *bmp, int x, int =
y);</B></TT><BR><BR>Retorna o=20
c=F3digo de cor da coordenada (x, y) no bitmap apontado por =
<TT><B>bmp</B></TT>;=20
retorna -1 caso o ponto esteja fora do bitmap.</P>
<P><TT><B>void line(BITMAP *bmp, int x1, int y1, int x2, int y2, int=20
color);</B></TT><BR><BR>Desenha uma linha, no bitmap apontado por=20
<TT><B>bmp</B></TT>, da coordenada (<TT><B>x1</B></TT>, =
<TT><B>y1</B></TT>) at=E9=20
a coordenada (<TT><B>x2</B></TT>, <TT><B>y2</B></TT>), utilizando a cor=20
especificada por <TT><B>color</B></TT>.</P>
<P><TT><B>void hline(BITMAP *bmp, int x1, int y, int x2, int=20
color);</B></TT><BR><BR>Desenha uma linha horizontal, no bitmap apontado =
por=20
<TT><B>bmp</B></TT>, da coordenada (<TT><B>x1</B></TT>, =
<TT><B>y</B></TT>) at=E9 a=20
coordenada (<TT><B>x2</B></TT>, <TT><B>y</B></TT>), utilizando a cor=20
especificada por <TT><B>color</B></TT>.</P>
<P><TT><B>void vline(BITMAP *bmp, int x, int y1, int y2, int=20
color);</B></TT><BR><BR>Desenha uma linha vertical, no bitmap apontado =
por=20
<TT><B>bmp</B></TT>, da coordenada (<TT><B>x</B></TT>, =
<TT><B>y1</B></TT>) at=E9 a=20
coordenada (<TT><B>x</B></TT>, <TT><B>y2</B></TT>), utilizando a cor=20
especificada por <TT><B>color</B></TT>.</P><A name=3Dvideo_bmp_rect>
<P><TT><B>void rect(BITMAP *bmp, int x1, int y1, int x2, int y2, int=20
color);</B></TT><BR><BR>Desenha a borda de um ret=E2ngulo, no bitmap =
apontado por=20
<TT><B>bmp</B></TT>, da coordenada (<TT><B>x1</B></TT>, =
<TT><B>y1</B></TT>) at=E9=20
a coordenada (<TT><B>x2</B></TT>, <TT><B>y2</B></TT>), utilizando a cor=20
especificada por <TT><B>color</B></TT>.</P>
<P><TT><B>void rectfill(BITMAP *bmp, int x1, int y1, int x2, int y2, int =

color);</B></TT><BR><BR>Desenha um ret=E2ngulo, no bitmap apontado por=20
<TT><B>bmp</B></TT>, da coordenada (<TT><B>x1</B></TT>, =
<TT><B>y1</B></TT>) at=E9=20
a coordenada (<TT><B>x2</B></TT>, <TT><B>y2</B></TT>), utilizando a cor=20
especificada por <TT><B>color</B></TT>.</P>
<P><TT><B>void triangle(BITMAP *bmp, int x1, int y1, int x2, int y2, int =
x3, int=20
y3, int color);</B></TT><BR><BR>Desenha um tri=E2ngulo, no bitmap =
apontado por=20
<TT><B>bmp</B></TT>, com v=E9rtices (<TT><B>x1</B></TT>, =
<TT><B>y1</B></TT>),=20
(<TT><B>x2</B></TT>, <TT><B>y2</B></TT>) e (<TT><B>x3</B></TT>,=20
<TT><B>y3</B></TT>).</P>
<P><TT><B>void polygon(BITMAP *bmp, int vertices, int *points, int=20
color);</B></TT><BR><BR>Desenha um pol=EDgono, no bitmap apontado por=20
<TT><B>bmp</B></TT>, com <TT><B>vertices</B></TT> v=E9rtices =
especificados pelo=20
vetor <TT><B>points</TT></B> de pares de coordenadas (x, y), com cor=20
<TT><B>color</B></TT>. Por exemplo:</P><TT>
<OL>int *pontos =3D { 1, 1, 2, 4, 6, 3, 5, 5 };<BR>BITMAP=20
  *bmp;<BR><BR>(...)<BR><BR>bmp =3D create_bitmap(50, =
50);<BR>polygon(bmp, 4,=20
  pontos, 100);<BR><BR>(...)<BR><BR></OL></TT>
<P>ir=E1 desenhar um quadril=E1tero com v=E9rtices (1, 1), (2, 4), (6, =
3), (5, 5) no=20
bitmap <TT><B>bmp</B></TT> com cor 100.</P>
<P><TT><B>void circle(BITMAP *bmp, int x, int y, int radius, int=20
color);</B></TT><BR><BR>Desenha uma circunfer=EAncia, no bitmap apontado =
por=20
<TT><B>bmp</B></TT>, com centro (<TT><B>x</B></TT>, <TT><B>y</B></TT>) e =
raio=20
<TT><B>radius</B></TT>, utilizando a cor especificada por=20
<TT><B>color</B></TT>.</P>
<P><TT><B>void circlefill(BITMAP *bmp, int x, int y, int radius, int=20
color);</B></TT><BR><BR>Desenha um c=EDrculo, no bitmap apontado por=20
<TT><B>bmp</B></TT>, com centro (<TT><B>x</B></TT>, <TT><B>y</B></TT>) e =
raio=20
<TT><B>radius</B></TT>, utilizando a cor especificada por=20
<TT><B>color</B></TT>.</P><A name=3Dvideo_bmp_blit>
<P><TT><B>void blit(BITMAP *source, BITMAP *dest, int source_x, int =
source_y,=20
int dest_x, int dest_y, int width, int height);</B></TT><BR><BR>Copia =
uma =E1rea=20
retangular, de largura <TT><B>width</B></TT> e altura =
<TT><B>height</B></TT>, da=20
coordenada (<TT><B>source_x</B></TT>, <TT><B>source_y</B></TT>) do =
bitmap=20
apontado por <TT><B>source</B></TT> para a coordenada =
(<TT><B>dest_x</B></TT>,=20
<TT><B>dest_y</B></TT>) do bitmap apontado por <TT><B>dest</B></TT>. <A=20
name=3Dvideo_bmp_draw_sprite>
<P><TT><B>void draw_sprite(BITMAP *bmp, BITMAP *sprite, int x, int=20
y);</B></TT><BR><BR>Copia inteiramente o bitmap apontado por=20
<TT><B>sprite</B></TT> na coordenada (<TT><B>x</B></TT>, =
<TT><B>y</B></TT>) do=20
bitmap apontado por <TT><B>bmp</B></TT>. Equivalente a=20
blit(<TT><B>sprite</B></TT>, <TT><B>bmp</B></TT>, 0, 0, x, y,=20
<TT><B>sprite-&gt;w</B></TT>, <TT><B>sprite-&gt;h</B></TT>).</P>
<P>A grande diferen=E7a entre as fun=E7=F5es <A=20
href=3D"http://equipe.nce.ufrj.br/adriano/c/apostila/allegro/docs/funcoes=
.html#video_bmp_blit"><TT>blit</TT></A>=20
e <TT>draw_sprite</TT> =E9 que a primeira desenha o bitmap como ele =E9, =
enquanto a=20
segunda trata como transparente as cores 0 (normalmente preto, no modo 8 =
bits) e=20
rosa claro (nos outros modos).</P>
<HR>
<A name=3Dvideo_pal>
<H3>2.3. Fun=E7=F5es de Paleta</H3>Todas as fun=E7=F5es de desenho do =
Allegro usam=20
par=E2metros inteiros para representar cores. No modo de 256 cores, =
esses valores=20
correspondem a =EDndices de um vetor, onde cada elemento =E9 uma =
estrutura que=20
cont=E9m as intensidades de vermelho, verde e azul de cada uma das 256 =
cores=20
poss=EDveis. Este vetor =E9 denominado paleta. Para declar=E1-la, =
digite: <TT>
<OL>PALETTE nome_da_paleta;</OL></TT>O Allegro define algumas paletas =
padr=F5es,=20
que podem ser utilizadas pelo usu=E1rio para determinadas situa=E7=F5es. =
S=E3o elas:=20
<P><TT><B>extern PALETTE desktop_palette;</B></TT><BR><BR>Esta paleta =
era=20
utilizada pelo Atari ST. =C9 utilizada pelos programas de teste e =
exemplo do=20
Allegro e =E9 a paleta padr=E3o utilizada pelo mesmo, caso nenhuma outra =
paleta seja=20
setada.</P><A name=3Dvideo_pal_black_palette>
<P><TT><B>extern PALETTE black_palette;</B></TT><BR><BR>Nesta paleta, =
todas as=20
256 cores poss=EDveis correspondem a cor preta. Esta paleta =E9 =
utilizada pelas=20
func=F5es de <I>fade</I>, e pode ser utilizada tamb=E9m pelo usu=E1rio =
em determinadas=20
situa=E7=F5es, em conjunto com a fun=E7=E3o <A=20
href=3D"http://equipe.nce.ufrj.br/adriano/c/apostila/allegro/docs/funcoes=
.html#video_pal_set_palette"><TT>set_palette</TT></A>.</P><A=20
name=3Dvideo_pal_set_palette>
<P><TT><B>void set_palette(PALETTE p);</B></TT><BR><BR>Seleciona a =
paleta=20
especificada por <TT><B>p</B></TT> como a paleta a ser utilizada.</P>
<P><TT><B>void set_palette_range(PALETTE p, int from, int to, int=20
vsync);</B></TT><BR><BR>Seleciona, da paleta especificada por =
<TT><B>p</B></TT>,=20
os =EDndices de <TT><B>from</B></TT> at=E9 <TT><B>to</B></TT>. Se=20
<TT><B>vsync</B></TT> tiver um valor verdadeiro, o Allegro espera pelo =
retra=E7o=20
vertical antes de selecionar a paleta. Tem o mesmo efeito da fun=E7=E3o =
<A=20
href=3D"http://equipe.nce.ufrj.br/adriano/c/apostila/allegro/docs/funcoes=
.html#video_pal_set_palette"><TT>set_palette</TT></A>,=20
com a diferen=E7a que apenas um trecho da paleta =E9 selecionado para =
uso.</P>
<P><TT><B>void get_palette(PALETTE p);</B></TT><BR><BR>Guarda a paleta =
utilizada=20
atualmente em <TT><B>p</B></TT>.</P>
<P><TT><B>void get_palette_range(PALETTE p, int from, int=20
to);</B></TT><BR><BR>Guarda parte da paleta utilizada atualmente em=20
<TT><B>p</B></TT>, com =EDndices de <TT><B>from</B></TT> at=E9=20
<TT><B>to</B></TT>.</P><A name=3Dvideo_pal_fade_in>
<P><TT><B>void fade_in(PALETTE p, int speed);</B></TT><BR><BR>Altera=20
gradualmente as cores da paleta atual, desde a <A=20
href=3D"http://equipe.nce.ufrj.br/adriano/c/apostila/allegro/docs/funcoes=
.html#video_pal_black_palette"><TT>black_palette</TT></A>=20
at=E9 a paleta <TT><B>p</B></TT>, com velocidade <TT><B>speed</B></TT> =
(1 -=20
devagar, 64 - muito r=E1pido).</P><A name=3Dvideo_pal_fade_out>
<P><TT><B>void fade_out(int speed);</B></TT><BR><BR>Altera gradualmente =
as cores=20
da plaheta atual at=E9 atingir a <A=20
href=3D"http://equipe.nce.ufrj.br/adriano/c/apostila/allegro/docs/funcoes=
.html#video_pal_black_palette"><TT>black_palette</TT></A>,=20
com velocidade <TT><B>speed</B></TT> (1 - devagar, 64 - muito =
r=E1pido).</P>
<P><TT><B>void fade_in_range(PALETTE p, int speed, int from, int=20
to);</B></TT><BR><BR>Altera gradualmente as cores da paleta atual, dos =
=EDndices=20
de <TT><B>from</B></TT> at=E9 <TT><B>to</B></TT>, desde a <A=20
href=3D"http://equipe.nce.ufrj.br/adriano/c/apostila/allegro/docs/funcoes=
.html#video_pal_black_palette"><TT>black_palette</TT></A>=20
at=E9 a paleta <TT><B>p</B></TT>, com velocidade <TT><B>speed</B></TT> =
(1 -=20
devagar, 64 - muito r=E1pido).</P>
<P><TT><B>void fade_from(PALETTE source, PALETTE dest, int=20
speed);</B></TT><BR><BR>Atlera gradualmente as cores da paleta atual, =
desde a=20
paleta <TT><B>source</B></TT> at=E9 a paleta <TT><B>dest</B></TT>, com =
velocidade=20
<TT><B>speed</B></TT> (1 - devagar, 64 - muito r=E1pido).</P>
<HR>
<A name=3Dvideo_font>
<H3>2.4. Fun=E7=F5es de Fonte</H3>Assim como para os bitmaps e paletas, =
o Allegro=20
define um tipo FONT, que cont=E9m a descri=E7=E3o de fontes que podem =
ser desenhadas=20
na tela. Para declarar uma fonte, digite: <TT>
<OL>FONT *nome_da_fonte;</OL></TT>
<P><TT><B>extern FONT *font;</B></TT><BR><BR>Esta fonte =E9 utilizada =
como padr=E3o=20
para determinadas tarefas do Allegro, e pode ser alterada para que o =
Allegro=20
utilize uma nova fonte nessas fun=E7=F5es.</P><A =
name=3Dvideo_font_text_mode>
<P><TT><B>void text_mode(int mode);</B></TT><BR><BR>Altera o modo de =
desenho do=20
texto. Se <TT><B>mode</B></TT> for 0 (zero) ou positivo, o fundo dos =
caracteres=20
ter=E1 a cor de c=F3digo <TT><B>mode</B></TT>. Caso seja negativo, o =
fundo ser=E1=20
transparente. O padr=E3o =E9 0 (zero).</P><A name=3Dvideo_font_textout>
<P><TT><B>void textout(BITMAP *bmp, FONT *f, unsigned char *s, int x, =
int y, int=20
color);</B></TT><BR><BR>Escreve a string <TT><B>s</B></TT>, na =
coordenada=20
(<TT><B>x</B></TT>, <TT><B>y</B></TT>) do bitmap apontado por=20
<TT><B>bmp</B></TT>, utilizando a fonte apontada por <TT><B>f</B></TT> e =
a cor=20
<TT><B>color</B></TT>. Se o valor de <TT><B>color</B></TT> for -1, a cor =

utilizada ser=E1 a cor original do bitmap da fonte.</P><A=20
name=3Dvideo_font_textout_centre>
<P><TT><B>void textout_centre(BITMAP *bmp, FONT *f, unsigned char *s, =
int x, int=20
y, int color);</B></TT><BR><BR>Semelhante a fun=E7=E3o <A=20
href=3D"http://equipe.nce.ufrj.br/adriano/c/apostila/allegro/docs/funcoes=
.html#video_font_textout"><TT>textout</TT></A>,=20
por=E9m, imprime a string <TT><B>s</B></TT> centralizada na coordenada=20
especificada.</P><A name=3Dvideo_font_textprintf>
<P><TT><B>void textprintf(BITMAP *bmp, FONT *f, int x, int y, int color, =
char=20
*fmt, ...);</B></TT><BR><BR>Escreve um texto formatado (no mesmo estilo =
da=20
fun=E7=E3o printf) no bitmap apontado por <TT><B>bmp</B></TT>, na =
coordenada=20
(<TT><B>x</B></TT>, <TT><B>y</B></TT>), utilizando a fonte apontada por=20
<TT><B>f</B></TT> e a cor <TT><B>color</B></TT>.</P><A=20
name=3Dvideo_font_textprintf_centre>
<P><TT><B>void textprintf_centre(BITMAP *bmp, FONT *f, int x, int y, int =
color,=20
char *fmt, ...);</B></TT><BR><BR>Semelhante a fun=E7=E3o <A=20
href=3D"http://equipe.nce.ufrj.br/adriano/c/apostila/allegro/docs/funcoes=
.html#video_font_textprintf"><TT>textprintf</TT></A>,=20
por=E9m, imprime o texto formatado centralizado na coordenada=20
especificada.</P><IMG alt=3D"barra horizontal azul" hspace=3D5=20
src=3D"http://equipe.nce.ufrj.br/adriano/figuras/bluebar.gif" =
width=3D"100%"=20
align=3Dleft><BR><A name=3Dkeyboard>
<H2>3. Fun=E7=F5es de Teclado</H2><A name=3Dkeyboard_install_keyboard>
<P><TT><B>int install_keyboard();</B></TT><BR><BR>Inicializa o teclado =
para ser=20
usado pelo Allegro. Deve-se chamar esta fun=E7=E3o antes de qualquer =
outra fun=E7=E3o de=20
teclado. Ap=F3s a chamada desta fun=E7=E3o, n=E3o se pode mais utilizar =
as fun=E7=F5es=20
padr=F5es de acesso ao teclado (scanf, getchar, etc.). Para usar as =
fun=E7=F5es=20
padr=F5es de acesso ao teclado novamente utilize a fun=E7=E3o <A=20
href=3D"http://equipe.nce.ufrj.br/adriano/c/apostila/allegro/docs/funcoes=
.html#keyboard_remove_keyboard"><TT>remove_keyboard</TT></A>.</P><A=20
name=3Dkeyboard_remove_keyboard>
<P><TT><B>void remove_keyboard();</B></TT><BR><BR>Devolve o controle do =
teclado=20
a BIOS. Faz o contr=E1rio da fun=E7=E3o <A=20
href=3D"http://equipe.nce.ufrj.br/adriano/c/apostila/allegro/docs/funcoes=
.html#keyboard_install_keyboard"><TT>install_keyboard</TT></A>.=20
Normalmente, n=E3o =E9 necess=E1rio chamar esta fun=E7=E3o, pois a =
fun=E7=E3o <A=20
href=3D"http://equipe.nce.ufrj.br/adriano/c/apostila/allegro/docs/funcoes=
.html#bas_allegro_exit"><TT>allegro_exit</TT></A>=20
j=E1 o faz.</P><A name=3Dkeyboard_clear_keybuf>
<P><TT><B>void clear_keybuf();</B></TT><BR><BR>Limpa o <I>buffer</I> do =
teclado.=20
Qualquer tecla anteriormente pressionada que ainda n=E3o tenha sido lida =
pela=20
fun=E7=E3o <A=20
href=3D"http://equipe.nce.ufrj.br/adriano/c/apostila/allegro/docs/funcoes=
.html#keyboard_readkey"><TT>readkey</TT></A>=20
ser=E1 perdida.</P><A name=3Dkeyboard_keypressed>
<P><TT><B>int keypressed();</B></TT><BR><BR>Retorna verdadeiro caso =
alguma tecla=20
tenha sido pressionada e esteja no <I>buffer</I> a espera da leitura.=20
Equivalente a fun=E7=E3o kbhit da conio.</P><A name=3Dkeyboard_readkey>
<P><TT><B>int readkey();</B></TT><BR><BR>Retorna o pr=F3ximo caractere =
do=20
<I>buffer</I> do teclado. Se o <I>buffer</I> estiver vazio, a fun=E7=E3o =
espera at=E9=20
que uma tecla seja pressionada. O byte baixo do valor retornado cont=E9m =
o c=F3digo=20
ASCII do caracter, enquanto o byte alto retorna o scancode da tecla. O =
scancode=20
n=E3o =E9 afetado pelas teclas SHIFT, CTRL e ALT. O c=F3digo ASCII =E9 =
afetado=20
normalmente pelas teclas SHIFT e CTRL (a tecla SHIFT altera o caso, =
enquanto a=20
tecla CTRL retorna a posi=E7=E3o da tecla pressionada simultaneamente). =
Ao=20
pressionar a tecla ALT o c=F3digo ASCII retornado =E9 0 (zero), =
retornando apenas o=20
scancode (ainda no byte alto). Por exemplo:</P><TT>
<OL>/* Pelo codigo ASCII */<BR>if ((readkey() &amp; 0xFF) =3D=3D =
'd')<BR>
  <OL>printf("Voce pressionou a tecla 'd'\n");</OL><BR><BR>/* Pelo =
scancode=20
  */<BR>if ((readkey() &gt;&gt; 8) =3D=3D KEY_SPACE)<BR>
  <OL>printf("Voce pressionou a tecla Espa=E7o\n");</OL><BR><BR>/* =
Pressionando=20
  CTRL+[letra] */<BR>if ((readkey() &amp; 0xFF) =3D=3D 3)<BR>
  <OL>printf("Voce pressionou CTRL+C\n");</OL><BR><BR>/* Pressionando=20
  ALT+[letra] */<BR>if (readkey() =3D=3D (KEY_X &lt;&lt; 8))<BR>
  <OL>printf("Voce pressionou ALT+X\n");</OL><BR></OL></TT>
<P><TT><B>extern volatile char key[KEY_MAX];</B></TT><BR><BR>Vetor de=20
<TT><B>KEY_MAX</B></TT> posi=E7=F5es, cada uma representando uma das =
teclas do=20
teclado. Caso o valor de key[KEY_TECLA] seja verdadeiro, a tecla est=E1 =
sendo=20
pressionada. Por exemplo:</P><TT>
<OL>if (key[KEY_D])<BR>
  <OL>printf("Voce pressionou a tecla 'D'\n");</OL><BR><BR>if=20
  (key[KEY_SPACE])<BR>
  <OL>printf("Voce pressionou a tecla Espa=E7o\n");</OL><BR><BR>if=20
  ((key[KEY_CTRL]) &amp;&amp; (key[KEY_C]))<BR>
  <OL>printf("Voce pressionou CTRL+C\n");</OL><BR><BR>if ((key[KEY_ALT]=20
  &amp;&amp; (key[KEY_X]))<BR>
  <OL>printf("Voce pressionou ALT+X\n");</OL><BR></OL></TT>
<P>Note que key[KEY_TECLA] apenas informa o estado da tecla, n=E3o =
espera pelo=20
pressionamento da mesma.</P><IMG alt=3D"barra horizontal azul" =
hspace=3D5=20
src=3D"http://equipe.nce.ufrj.br/adriano/figuras/bluebar.gif" =
width=3D"100%"=20
align=3Dleft><BR><A name=3Dmouse>
<H2>4. Fun=E7=F5es de Mouse</H2><A name=3Dmouse_install_mouse>
<P><TT><B>int install_mouse();</B></TT><BR><BR>Inicializa o mouse para =
ser usado=20
pelo Allegro. =C9 necess=E1rio chamar esta fun=E7=E3o antes de qualquer =
outra fun=E7=E3o de=20
mouse. Retorna -1 se ocorrer algum erro; caso contr=E1rio, retorna o =
n=FAmero de=20
bot=F5es do mouse.</P>
<P><TT><B>void remove_mouse();</B></TT><BR><BR>Remove o controle do =
Allegro=20
sobre o mouse. Normalmente, n=E3o =E9 necess=E1rio chamar esta =
fun=E7=E3o, pois a fun=E7=E3o=20
<A=20
href=3D"http://equipe.nce.ufrj.br/adriano/c/apostila/allegro/docs/funcoes=
.html#bas_allegro_exit"><TT>allegro_exit</TT></A>=20
j=E1 o faz.</P><A name=3Dmouse_mouse_x_y>
<P><TT><B>extern volatile int mouse_x;</B></TT><BR><TT><B>extern =
volatile int=20
mouse_y;</B></TT><BR><BR>Guardam os valores da posi=E7=E3o x e y do =
cursor do=20
mouse.</P><A name=3Dmouse_mouse_b>
<P><TT><B>extern volatile int mouse_b;</B></TT><BR><BR>Guarda o estado =
atual do=20
pressionamento dos bot=F5es do mouse. O bit 0 de <TT><B>mouse_b</B></TT> =
guarda o=20
estado do bot=E3o esquerdo, o bit 1 o do bot=E3o esquerdo, e o bit 2 o =
do bot=E3o do=20
meio.</P><TT>
<OL>if (mouse_b &amp; 1)<BR>
  <OL>printf("Bot=E3o esquerdo do mouse pressionado\n");</OL><BR><BR>if =
(!(mouse_b=20
  &amp; 2))<BR>
  <OL>printf("Bot=E3o direito do mouse n=E3o =
pressionado\n");</OL><BR><BR>if=20
  (mouse_b &amp; 4)<BR>
  <OL>printf("Bot=E3o do meio do mouse =
pressionado\n");</OL><BR></OL></TT>
<P><TT><B>void set_mouse_range(int x1, int y1, int x2, int=20
y2);</B></TT><BR><BR>Define a =E1rea onde o ponteiro do mouse pode se =
locomover na=20
tela. A =E1rea =E9 definida pelo ret=E2ngulo de coordenada superior =
esquerda=20
(<TT><B>x1</B></TT>, <TT><B>y1</B></TT>) e coordenada inferior direita=20
(<TT><B>x2</B></TT>, <TT><B>y2</B></TT>).</P>
<P><TT><B>void position_mouse(int x, int y);</B></TT><BR><BR>Move o =
ponteiro do=20
mouse para a coordenada (<TT><B>x</B></TT>, <TT><B>y</B></TT>).</P><A=20
name=3Dmouse_show_mouse>
<P><TT><B>void show_mouse(BITMAP *bmp);</B></TT><BR><BR>Mostra o =
ponteiro do=20
mouse no bitmap apontado por <TT><B>bmp</B></TT>. Funciona apenas se o =
<A=20
href=3D"http://equipe.nce.ufrj.br/adriano/c/apostila/allegro/docs/funcoes=
.html#outras_timer">timer</A>=20
estiver instalado. Para esconder o ponteiro do mouse, passe o valor=20
<TT><B>NULL</B></TT> como argumento. N=E3o =E9 recomend=E1vel desenhar =
na tela=20
enquanto o ponteiro do mouse estiver vis=EDvel, pois isto pode gerar =
manchas=20
provocadas pelo rastro do mouse. Tamb=E9m n=E3o =E9 uma boa id=E9ia =
esconder o mouse,=20
desenhar na tela e exibir o mouse novamente, pois isto faz com que o =
mouse fique=20
"piscando" na tela. O ideal =E9 que sejam utilizadas t=E9cnicas como o =
<A=20
href=3D"http://equipe.nce.ufrj.br/adriano/c/apostila/allegro/docs/tecnica=
s.html#double_buffering">double=20
buffering</A>.</P><IMG alt=3D"barra horizontal azul" hspace=3D5=20
src=3D"http://equipe.nce.ufrj.br/adriano/figuras/bluebar.gif" =
width=3D"100%"=20
align=3Dleft><BR><A name=3Dsound>
<H2>5. Fun=E7=F5es de Som</H2><A name=3Dsound_install_sound>
<P><TT><B>int install_sound(int digi_card, int midi_card, char=20
*cfg_path);</B></TT><BR><BR>Inicializa o m=F3dulo de som para ser usado =
com o=20
Allegro. Os par=E2metros <TT><B>digi_card</B></TT> e =
<TT><B>midi_card</B></TT>=20
referem-se, respectivamente, aos controladores de som digital e =
MIDI.</P>
<P>O valor de <TT><B>digi_card</B></TT> deve ser um dos abaixo:</P>
<CENTER>
<TABLE cols=3D2 width=3D"70%" border=3D1 ROWS=3D"10">
  <TBODY>
  <TR>
    <TD>DIGI_AUTODETECT</TD>
    <TD>instrui o Allegro a escolher o driver de som</TD></TR>
  <TR>
    <TD>DIGI_NONE</TD>
    <TD>sem som digital</TD></TR>
  <TR>
    <TD>DIGI_SB</TD>
    <TD>auto-detecta placas do tipo Sound Blaster</TD></TR>
  <TR>
    <TD>DIGI_SB10</TD>
    <TD>Sound Blaster 1.0 (8 bit mono)</TD></TR>
  <TR>
    <TD>DIGI_SB15</TD>
    <TD>Sound Blaster 1.5 (8 bit mono)</TD></TR>
  <TR>
    <TD>DIGI_SB20</TD>
    <TD>Sound Blaster 2.0 (8 bit mono)</TD></TR>
  <TR>
    <TD>DIGI_SBPRO</TD>
    <TD>Sound Blaster Pro (8 bit stereo)</TD></TR>
  <TR>
    <TD>DIGI_SB16</TD>
    <TD>Sound Blaster 16 (16 bit stereo)</TD></TR>
  <TR>
    <TD>DIGI_AUDIODRIVE</TD>
    <TD>ESS AudioDrive</TD></TR>
  <TR>
    <TD>DIGI_SOUNDSCAPE</TD>
    <TD>Ensoniq Soundscape</TD></TR></TBODY></TABLE></CENTER>
<P>O valor de <TT><B>midi_card</B></TT> deve ser um dos abaixo:</P>
<CENTER>
<TABLE cols=3D2 width=3D"70%" border=3D1 ROWS=3D"10">
  <TBODY>
  <TR>
    <TD>MIDI_AUTODETECT</TD>
    <TD>instrui o Allegro a escolher o driver de MIDI</TD></TR>
  <TR>
    <TD>MIDI_NONE</TD>
    <TD>sem som MIDI</TD></TR>
  <TR>
    <TD>MIDI_ADLIB</TD>
    <TD>auto-detecta sintetizadores do tipo Adlib ou Sound Blaster =
FM</TD></TR>
  <TR>
    <TD>MIDI_OPL2</TD>
    <TD>sintetizador OPL2 (mono, usado em Adlib e Sound =
Blaster)</TD></TR>
  <TR>
    <TD>MIDI_2XOPL2</TD>
    <TD>sintetizador OPL2 dual (stereo, usado em Sound Blaster =
Pro-I)</TD></TR>
  <TR>
    <TD>MIDI_OPL3</TD>
    <TD>sintetizador OPL3 (stereo, usado em Sound Blaster Pro-II e=20
acima)</TD></TR>
  <TR>
    <TD>MIDI_SB_OUT</TD>
    <TD>interface MIDI Sound Blaster</TD></TR>
  <TR>
    <TD>MIDI_MPU</TD>
    <TD>interface MIDI MPU-401</TD></TR>
  <TR>
    <TD>MIDI_DIGMID</TD>
    <TD>sample-based software wavetable player</TD></TR>
  <TR>
    <TD>MIDI_AWE32</TD>
    <TD>AWE32 (EMU8000 chip)</TD></TR></TBODY></TABLE></CENTER>
<P>O par=E2metro <TT><B>cfg_path</B></TT> existe apenas para =
compatibilidade com=20
vers=F5es anteriores do Allegro. Ignore-o passando o valor=20
<TT><B>NULL</B></TT>.</P>
<P><TT><B>void remove_sound();</B></TT><BR><BR>Remove o m=F3dulo de som. =

Normalmente n=E3o =E9 necess=E1rio chamar esta fun=E7=E3o, pois a =
fun=E7=E3o <A=20
href=3D"http://equipe.nce.ufrj.br/adriano/c/apostila/allegro/docs/funcoes=
.html#bas_allegro_exit"><TT>allegro_exit</TT></A>=20
j=E1 o faz.</P><A name=3Dsound_load_midi>
<P><TT><B>MIDI *load_midi(char *filename);</B></TT><BR><BR>Carrega um =
arquivo=20
MIDI, retornando um ponteiro para uma estrutura <TT><B>MIDI</B></TT>. =
Caso=20
ocorra um erro, o valor <TT><B>NULL</B></TT> ser=E1 retornado.</P><A=20
name=3Dsound_play_midi>
<P><TT><B>int play_midi(MIDI *midi, int loop);</B></TT><BR><BR>Toca a =
MIDI=20
especificada por <TT><B>midi</B></TT>, parando de tocar qualquer =
m=FAsica que=20
estivesse sendo tocada anteriormente. Se a flag <TT><B>loop</B></TT> =
estiver=20
setada, a m=FAsica ser=E1 tocada at=E9 que a fun=E7=E3o seja novamente =
chamada para tocar=20
outra m=FAsica, ou a fun=E7=E3o <A=20
href=3D"http://equipe.nce.ufrj.br/adriano/c/apostila/allegro/docs/funcoes=
.html#sound_stop_midi"><TT>stop_midi</TT></A>=20
seja chamada. Caso a flag <TT><B>loop</B></TT> n=E3o esteja setada, a =
m=FAsica ir=E1=20
parar de tocar ao alcan=E7ar o final do MIDI. Retorna um valor diferente =
de zero=20
se um erro ocorrer.</P><A name=3Dsound_stop_midi>
<P><TT><B>void stop_midi();</B></TT><BR><BR>Faz parar de tocar qualquer =
m=FAsica=20
que esteja sendo tocada. Tem o mesmo efeito da instru=E7=E3o =
<TT><B>play_midi(NULL,=20
FALSE)</B></TT>.</P><A name=3Dsound_load_sample>
<P><TT><B>SAMPLE *load_sample(char *filename);</B></TT><BR><BR>Carrega =
um=20
arquivo sample, retornando um ponteiro para uma estrutura=20
<TT><B>SAMPLE</B></TT>. Caso ocorra um erro, o valor =
<TT><B>NULL</B></TT> ser=E1=20
retornado. Aceita arquivos do tipo WAV (mono e stereo) e VOC (mono) em =
formato 8=20
e 16 bits.</P><A name=3Dsound_play_sample>
<P><TT><B>int play_sample(SAMPLE *spl, int vol, int pam, int freq, int=20
loop);</B></TT><BR><BR>Inicializa o sample especificado por =
<TT><B>spl</B></TT>=20
utilizando determinados argumentos. O argumento <TT><B>vol</B></TT> =
determina o=20
volume (valores de 0 at=E9 255), o argumento <TT><B>pan</B></TT> =
determina o=20
balan=E7o (valores de 0 at=E9 255), o argumento <TT><B>freq</B></TT> =
determina a=20
frequ=EAncia com que o sample =E9 tocado (o valor 1000 faz com que o =
sample seja=20
tocado na mesma frequ=EAncia que foi gravado; o valor 2000 =E9 o dobro =
da=20
frequ=EAncia, etc.) e o argumento <TT><B>loop</B></TT> informa se o =
Allegro deve=20
repetir o sample infinitamente ou n=E3o.</P><A name=3Dsound_stop_sample>
<P><TT><B>void stop_sample(SAMPLE *spl);</B></TT><BR><BR>Faz parar de =
tocar o=20
sample especificado por <TT><B>spl</B></TT>. =C9 necess=E1rio chamar =
esta fun=E7=E3o=20
caso o sample tenha sido incializado com a flag <TT><B>loop</B></TT>=20
setada.</P><IMG alt=3D"barra horizontal azul" hspace=3D5=20
src=3D"http://equipe.nce.ufrj.br/adriano/figuras/bluebar.gif" =
width=3D"100%"=20
align=3Dleft><BR><A name=3Doutras>
<H2>6. Outras Fun=E7=F5es</H2><A name=3Doutras_timer>
<H3>6.1. Fun=E7=F5es de Timer</H3><A name=3Doutras_timer_install_timer>
<P><TT><B>int install_timer();</B></TT><BR><BR>Inicializa o temporizador =
do=20
Allegro. =C9 necess=E1rio chamar esta fun=E7=E3o antes de usar qualquer =
fun=E7=E3o de timer,=20
bem como antes de mostrar o ponteiro do mouse ou tocar uma MIDI.</P>
<P><TT><B>void remove_timer();</B></TT><BR><BR>Remove o temporizador do =
Allegro.=20
Normalmente, n=E3o =E9 necess=E1rio chamar esta fun=E7=E3o, pois a =
fun=E7=E3o <A=20
href=3D"http://equipe.nce.ufrj.br/adriano/c/apostila/allegro/docs/funcoes=
.html#bas_allegro_exit"><TT>allegro_exit</TT></A>=20
j=E1 o faz.</P>
<P><TT><B>int install_int(void (*proc)(), int =
speed);</B></TT><BR><BR>Inicializa=20
um temporizador para que, a cada intervalo de <TT><B>speed</B></TT>=20
milisegundos, a fun=E7=E3o <TT><B>proc</B></TT> seja chamada. Caso a =
fun=E7=E3o=20
install_int seja chamada antes da inicializa=E7=E3o do temporizador do =
Allegro, a=20
fun=E7=E3o <A=20
href=3D"http://equipe.nce.ufrj.br/adriano/c/apostila/allegro/docs/funcoes=
.html#outras_timer_install_timer"><TT>install_timer</TT></A>=20
ser=E1 automaticamente chamada.</P>
<P><TT><B>void remove_int(void (*proc)());</B></TT><BR><BR>Remove o =
temporizador=20
que chama a fun=E7=E3o <TT><B>proc</B></TT>. A remo=E7=E3o dos =
temporizadores =E9 feita=20
automaticamente pela fun=E7=E3o <A=20
href=3D"http://equipe.nce.ufrj.br/adriano/c/apostila/allegro/docs/funcoes=
.html#bas_allegro_exit"><TT>allegro_exit</TT></A>.</P>
<P><TT><B>LOCK_VARIABLE(<I>variavel</I>)<BR>LOCK_FUNCTION(<I>funcao</I>)<=
BR>END_OF_FUNCTION(<I>funcao</I>)</B></TT><BR><BR>Essas=20
tr=EAs macros s=E3o necess=E1rias quando utiliza-se temporizadores. As =
macros=20
<TT><B>LOCK_VARIABLE</B></TT> e <TT><B>LOCK_FUNCTION</B></TT> bloqueiam =
a =E1rea=20
de mem=F3ria ultilizada pela vari=E1vel ou fun=E7=E3o, enquanto a macro=20
<TT><B>END_OF_FUNCTION</B></TT> determina o final de uma fun=E7=E3o =
dentro do=20
programa. Por exemplo:</P><TT>
<OL>int x;<BR><BR>(...)<BR><BR>int aumenta_x()<BR>{<BR>
  <OL>x++;</OL><BR>}<BR>END_OF_FUNCTION(aumenta_x);<BR><BR>int =
main()<BR>{<BR>
  <OL><BR>(...)<BR><BR>/*
    <OL>Bloqueia a variavel x e a funcao aumenta_x<BR>e instala um=20
      temporizador que chamara a<BR>funcao aumenta_x a cada 0,2 segundo=20
      (200<BR>milisegundos).=20
    =
</OL>*/<BR>LOCK_VARIABLE(x);<BR>LOCK_FUNCTION(aumenta_x);<BR>install_int(=
aumenta_x,=20
    200);<BR><BR>(...)<BR><BR></OL>}<BR></OL></TT>
<P><TT><B>void rest(long time);</B></TT><BR><BR>Provoca uma pausa de=20
<TT><B>time</B></TT> milisegundos no programa.</P>
<HR>
<A name=3Doutras_datafile>
<H3>6.2. Fun=E7=F5es de DataFile</H3>
<P>DataFile =E9 um tipo especial de arquivo, com extens=E3o .dat, e que =
pode=20
armazenar diversos tipos de arquivos, como BitMaps, MIDIs, fontes, =
paletas, que=20
podem ser carregados e utilizados durante a execu=E7=E3o do =
programa.</P>
<P>Para criar um arquivo DataFile existe um utilit=E1rio chamado =
<I>Grabber</I>,=20
que se encontra no diret=F3rio <TT><B>tools</B></TT>, dentro do =
diret=F3rio=20
principal do Allegro. O programa possui uma interface que facilita a =
confec=E7=E3o=20
do arquivo DataFile.</P>
<P>Para acessar um arquivo DataFile num programa, utiliza-se o tipo=20
<TT><B>DATAFILE</B></TT>, da seguinte maneira:</P><TT><B>
<OL>DATAFILE *dat;</OL></B></TT>
<P>Depois de determinar um ponteiro para o arquivo DataFile, pode-se =
abri-lo=20
utilizando a fun=E7=E3o <A=20
href=3D"http://equipe.nce.ufrj.br/adriano/c/apostila/allegro/docs/funcoes=
.html#outras_datafile_load_datafile"><TT>load_datafile</TT></A>,=20
descrita abaixo:</P><A name=3D#outras_datafile_load_datafile>
<P><TT><B>DATAFILE *load_datafile(const char =
*filename);</B></TT><BR><BR>Abre o=20
arquivo de nome <TT><B>filename</B></TT> como um arquivo datafile, =
preparando-o=20
para a leitura de seus dados. Retorna <TT><B>NULL</B></TT> caso ocorra =
algum=20
erro.</P>
<HR>
<A name=3D#outras_config>
<H3>6.3. Fun=E7=F5es de Arquivos de Configura=E7=E3o</H3><TT><B>void=20
set_config_file(const char *filename);</B></TT><BR><BR>Instrui o Allegro =
a=20
utilizar o arquivo <TT><B>filename</B></TT> para as futuras chamadas a =
outras=20
fun=E7=F5es de arquivos de configura=E7=E3o. Caso as outras fun=E7=F5es =
sejam chamadas antes=20
da fun=E7=E3o set_config_file, o Allegro utiliza o arquivo=20
<TT><B>allegro.cfg</B></TT> do diret=F3rio atual como o arquivo de =
configura=E7=E3o a=20
ser lido.
<P></P><A name=3Doutras_config_set_config_string>
<P><TT><B>void set_config_string(const char *section, const char *name, =
const=20
char *val);</B></TT><BR><BR>Escreve uma string no arquivo de =
configura=E7=E3o atual=20
na chave <TT><B>name</B></TT> da se=E7=E3o <TT><B>section</B></TT>. Caso =

<TT><B>val</B></TT> seja <TT><B>NULL</B></TT>, a chave =E9 removida do =
arquivo.=20
Caso <TT><B>section</B></TT> seja <TT><B>NULL</B></TT>, a chave =E9 =
escrita na=20
raiz do arquivo de configura=E7=E3o. Os dados s=E3o escritos no arquivo =
ao chamar a=20
fun=E7=E3o <A=20
href=3D"http://equipe.nce.ufrj.br/adriano/c/apostila/allegro/docs/funcoes=
.html#bas_allegro_exit"><TT>allegro_exit</TT></A>.</P>
<P>As linhas iniciadas com um '#' n=E3o s=E3o lidas ou escritas no =
arquivo de=20
configura=E7=E3o, sendo tratadas como coment=E1rios.</P><A=20
name=3Doutras_config_set_config_id>
<P><TT><B>void set_config_id(const char *section, const char *name, int=20
val);</B></TT><BR><BR>Faz o mesmo que a fun=E7=E3o <A=20
href=3D"http://equipe.nce.ufrj.br/adriano/c/apostila/allegro/docs/funcoes=
.html#outras_config_set_config_string"><TT>set_config_string</TT></A>,=20
exceto pelo fato de escrever um ID no arquivo, ao inv=E9s de uma string. =
Para cada=20
valor de <TT><B>val</B></TT> existe um ID de 4 letras correspondente. =
Isto =E9=20
=FAtil para guardar informa=E7=F5es sobre placas de v=EDdeo e som nos =
arquivos de=20
configura=E7=E3o.</P>
<P><TT><B>void set_config_int(const char *section, const char *name, int =

val);</B></TT><BR><TT><B>void set_config_hex(const char *section, const =
char=20
*name, int val);</B></TT><BR><TT><B>void set_config_float(const char =
*section,=20
const char *name, float val);</B></TT><BR><BR>Fazem o mesmo que a =
fun=E7=E3o <A=20
href=3D"http://equipe.nce.ufrj.br/adriano/c/apostila/allegro/docs/funcoes=
.html#outras_config_set_config_string"><TT>set_config_string</TT></A>,=20
exceto pelo fato de escreverem, respectivamente, n=FAmeros inteiros, =
hexadecimais=20
e de ponto flutuante.</P><A name=3Doutras_config_get_config_string>
<P><TT><B>const char *get_config_string(const char *section, const char =
*name,=20
const char *def);</B></TT><BR><BR>L=EA uma string do arquivo de =
configura=E7=E3o atual=20
da chave <TT><B>name</B></TT> da se=E7=E3o <TT><B>section</B></TT>. Caso =

<TT><B>section</B></TT> seja <TT><B>NULL</B></TT>, a chave =E9 lida da =
raiz do=20
arquivo de configura=E7=E3o. Caso a chave n=E3o seja encontrada, o valor =
de=20
<TT><B>def</B></TT> =E9 retornado.</P>
<P><TT><B>int get_config_id(const char *section, const char *name, int=20
def);</B></TT><BR><BR>L=EA uma ID (veja em <A=20
href=3D"http://equipe.nce.ufrj.br/adriano/c/apostila/allegro/docs/funcoes=
.html#outras_config_set_config_id"><TT>set_config_id</TT></A>)=20
do arquivo de configura=E7=E3o atual (mais detalhes em <A=20
href=3D"http://equipe.nce.ufrj.br/adriano/c/apostila/allegro/docs/funcoes=
.html#outras_config_get_config_string"><TT>get_config_string</TT></A>).</=
P>
<P><TT><B>int get_config_int(const char *section, const char *name, int=20
def);</B></TT><BR><TT><B>int get_config_hex(const char *section, const =
char=20
*name, int def);</B></TT><BR><TT><B>float get_config_float(const char =
*section,=20
const char *name, float def);</B></TT><BR><BR>L=EAem, respectivamente, =
um n=FAmero=20
inteiro, hexadecimal e de ponto flutuante, do arquivo de =
configura=E7=E3o atual=20
(mais detalhes em <A=20
href=3D"http://equipe.nce.ufrj.br/adriano/c/apostila/allegro/docs/funcoes=
.html#outras_config_get_config_string"><TT>get_config_string</TT></A>).</=
P><IMG=20
alt=3D"barra horizontal azul" hspace=3D5=20
src=3D"http://equipe.nce.ufrj.br/adriano/figuras/bluebar.gif" =
width=3D"100%"=20
align=3Dleft><BR>
<P>
<CENTER><A=20
href=3D"http://equipe.nce.ufrj.br/adriano/c/apostila/allegro/docs/allegro=
.html#indice"><IMG=20
height=3D30 hspace=3D5=20
src=3D"http://equipe.nce.ufrj.br/adriano/c/apostila/allegro/docs/return.g=
if"=20
width=3D30 align=3Dcenter></A> <A=20
href=3D"http://equipe.nce.ufrj.br/adriano/c/apostila/allegro/docs/allegro=
.html#indice">=CDndice=20
Geral do Allegro</A> </CENTER>
<P></P></BODY></HTML>

------=_NextPart_000_0000_01C9ABCF.9AFEF570
Content-Type: image/gif
Content-Transfer-Encoding: base64
Content-Location: http://equipe.nce.ufrj.br/adriano/figuras/min_peq.gif

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
QoLqWtv61qhm9TR3zeteryAEADs=

------=_NextPart_000_0000_01C9ABCF.9AFEF570
Content-Type: image/gif
Content-Transfer-Encoding: base64
Content-Location: http://equipe.nce.ufrj.br/adriano/figuras/bluebar.gif

R0lGODdhHAIEAKEAAAAAAAAAgAAA/wAAACwAAAAAHAIEAAAC/oSPqcsXbh6Qr85rM658Bg5+4kiW
5omm6sqOgvl+8SzXAX3n+cvvfg/8CYPE4Y7IS96UAqZzCW1Gpc2k9bqkVrfcrvcLDovH5LL5jE57
G2xKBAO3wOdyjb2Dx3s89v3H3xIoWBKjQ1NUVNPjY2izGMSIc2iESHk0hakVdanZ+eSZGUq1qVVp
anlqCvTJmuW6laUmOzvLhuBmq4B7wdvnG+e3wTcc8pcCyDfYUoijo0zo6BId2diYqog6xISKuJrd
CuopXvq6alV+RSsWW8VO5k4+Gu50rm6/1iCx4MY/1/tG598dYMYy6BmxwRigY89gKJMUrZKzSdam
SZx08ZtGIVXaMn3qOI/UNlal6sWTt9HjlHYlOdHjAu/eF4/pZIYpAAA7

------=_NextPart_000_0000_01C9ABCF.9AFEF570
Content-Type: image/gif
Content-Transfer-Encoding: base64
Content-Location: http://equipe.nce.ufrj.br/adriano/c/apostila/allegro/docs/return.gif

R0lGODdhKAAoAOMAAAAAAAD//x6Q/+bm+ofO676+vi9PTwAAgHCAkAAA/wAAAAAAAAAAAAAAAAAA
AAAAACwAAAAAKAAoAAAE/nDISau9eJrMOzbbUIxkaZ5oCkoF6L5wLMfiWqd4btZhq/84HssALO5a
PaJxKbyNDlCBIBAgUAlYAqDY9D0TCWn1mtVykUPSISwoV7GA7dnmLUjb5Sw1YOwq7Xh5VlZXQH4k
Um5jg4QEP4cjYoQBAHuNbzqQgJNxAIOLWTmaYlQACKeeoGVBaE4FYKWnsnGCdymasKanBbIInnm2
J5oACbIlvb9YdwIow8Uos1nLYMKtdXE40W1SYAnVdH8/2gJhYAdH4Euo3OQJUOhJ6uvda3IkmkWo
9O72I/hA+ty5O9CvwD+AvqBAKWjQWjgjCRc2c7iERESG/ihWHNGJVbqNJAUwljgIcuLHkqI0ovQY
byVLFh5iZrDm8seKGThz6tzJsyeICAA7

------=_NextPart_000_0000_01C9ABCF.9AFEF570--
