<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN""http://www.w3.org/TR/html4/loose.dtd"><html><head><meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"><title>Allegro Newbie Tutorial</title><link href="style1.css" rel="stylesheet" type="text/css"></head><body><center><div class="mainBox">  <div align="left">    <div class="borderBottom"><span class="headerText">Allegro Newbie Tutorial</span> : Lesson 8 - Bounding Box Collision Detection<br>       <br>       This tutorial will show you how to do a very simple implementation of collision detection using bounding boxes. The user can move both images.          <p> Controls:<br>  Up/Down/Left/Right : move image 1<br>  A/W/S/D : move image 2<br>  SPACE: draw bounding boxes.<br>  ESC: exit</p>         <p> This lesson also covers error checking when  creating/loading bitmaps, drawing primitive lines,  and displaying text. This is something new that was skipped in all the previous tutorials for simplicity. It is <em><strong>extremely good practice </strong></em>to do error checking for any function that allows you to do so. </p>    </div>    </div>  <div align="left"> The include and timer setup, and allegro initialization. This is routine stuff!<br>    <br>    <div class="codeBox">#include &lt;allegro.h&gt; // Include the allegro header file.<br>#include &lt;stdlib.h&gt; // Include the stdlib header for the exit() function.<br><br>/* Timer stuff */<br>volatile long speed_counter = 0; //&nbsp;A long integer which will store the value of the<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;speed counter.<p> void increment_speed_counter() //&nbsp;A function to increment the speed counter<br>  {<br>  speed_counter++; // This will just increment the speed counter by one.<br>  }<br>  END_OF_FUNCTION(increment_speed_counter); // Make sure you tell it that it's the end of the<br>  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// function (allegro specific)<br>  <br>  int main(int argc, char *argv[])<br>  {<br>  allegro_init(); // Initialize Allegro<br>  install_keyboard(); // Initialize keyboard routines<br>  install_timer(); // Initialize the timer routines<br></p><p> LOCK_VARIABLE(speed_counter); //Used to set the timer - which regulates the game's<br>  LOCK_FUNCTION(increment_speed_counter);//speed.<br>  install_int_ex(increment_speed_counter, BPS_TO_TIMER(60));//Set our BPS</p><p> set_color_depth(16); // Set the color depth</p><p> set_gfx_mode(GFX_AUTODETECT, 640,480,0,0); // Change our graphics mode to 640x480</p>    </div>    This bitmap is for double buffering.This is covered in a previous tutorial.    <p> However, this time, we do error checking - just to make sure the buffer was actually created properly. This is something you'll always want to do, since you can output an error and let the user know what didn't work!<br>    </p>    <div class="codeBox">BITMAP *buffer = create_bitmap(640,480); // Create a buffer for smooth animation.</div>    <p> We do a little test here to see if the bitmap was created.If the pointer is NULL, then that means it's not pointing toanything, thus the create_bitmap did not work. <br>    </p>    <div class="codeBox">if(buffer == NULL)<br>{</div>    <p>Here's some new stuff.This sets up allegro to go into a text only mode. This ensures that the message you want to display will be shown on any platform. </p>    <div class="codeBox">&nbsp;&nbsp;set_gfx_mode(GFX_TEXT,0,0,0,0);</div>        <br>This is a new function. It's called allegro_message.Obviously enough, it outputs a message.    <br><br><div class="codeBox">&nbsp;&nbsp;allegro_message(&quot;Could not create buffer!&quot;);</div><br>This function simply will stop the program Since the buffer could not be created we do not want to continue.<br><br><div class="codeBox">&nbsp;&nbsp;exit(EXIT_FAILURE);<br>}</div><br>Here we load the two bitmap images which we want to test collision for.<br>We test to see they were loaded correctly. If not, output an error message and exit.This is important. If your images can't load, when you try to blit them, your program will crash. Safely exiting is the better choice, by far!<br><br><div class="codeBox">BITMAP *image1 = load_bitmap(&quot;image1.bmp&quot;, NULL);//Load image 1  <p> if(image1 == NULL)<br>  {<br>&nbsp;&nbsp;set_gfx_mode(GFX_TEXT,0,0,0,0);&nbsp;//Set the screen mode for allegro messages<br>&nbsp;&nbsp;allegro_message(&quot;Could not load image1.bmp&quot;);<br>&nbsp;&nbsp;exit(EXIT_FAILURE);<br>  }</p>  <p> BITMAP *image2 = load_bitmap(&quot;image2.bmp&quot;, NULL);//Load image 2</p>  <p> if(image2 == NULL)<br>  {<br>&nbsp;&nbsp;set_gfx_mode(GFX_TEXT,0,0,0,0);&nbsp;//Set the screen mode for allegro messages<br>&nbsp;&nbsp;allegro_message(&quot;Could not load image2.bmp&quot;);<br>&nbsp;&nbsp;exit(EXIT_FAILURE);<br>  }</p></div>Next we're going to do a bit of variable declaring.First off, we're going to want to know the x and y positions of both images.<br><br><div class="codeBox">int image1_x_position = 0;&nbsp;//&nbsp;Set the x position of image 1 to 0.<br>int image1_y_position = 0;&nbsp;//&nbsp;Set the y position of image 1 to 0.  <p> int image2_x_position = 100;&nbsp;//&nbsp;Set the x position of image 2 to 100.<br>  int image2_y_position = 100;&nbsp;//&nbsp;Set the y position of image 2 to 100.</p></div>Next, we need to know where the bounding boxes are for these images. This is going to be a little complicated:<br>A box has four sides (it's square, or rectangle), so we will need to have 4 variables. Two y coordinates, and two x coordinates. The two y coordinates will represent the top and bottom &quot;sides&quot; of the box, while the x coordinates will represent the left and right &quot;sides&quot; of the box.<p> For the purposes of this tutorial, we will have the bounding box be the same size as the image we are going to apply it to. So, lets set these variables. We will need a total of 8. 4 for each image.</p><p> Note - bb stands for bounding box<br>  Here we set the left side of the bounding box to Image 1's x position. Why do we do this? Well, we want the bounding box to surround the image at all times, so we have to set it to the images current position. The x position of the image just so happens to be the same x coordinate of the left side of the box.</p><div class="codeBox">int image1_bb_left = image1_x_position;</div><br>The same idea goes for the top &quot;side&quot;<br><br><div class="codeBox">int image1_bb_top = image1_y_position;</div><br>Next we need to set the bottom and right &quot;sides&quot; of the box. Since we are going to use the bitmap's dimensions for the bounding boxes, this is simple. Since we don't want to have to keep track of the actual size of the image any time we change the image itself we can use a data member of the BITMAP structure to find out the width or height of  a bitmap image dynamically! We can do this using the pointer-&gt;w or pointer-&gt;h data members.<br><br> We know the width of the image. That is: (image1-&gt;w). If we have the left side of the box, well, the right side is just the image width away  from the left side.<br> <br><div class="codeBox">int image1_bb_right = (image1_bb_left + image1-&gt;w);</div><p>Use the same idea for the bottom.<br></p><div class="codeBox">int image1_bb_bottom = (image1_bb_top + image1-&gt;h);</div><p>Now, we will create the box for image 2 using the same principles.<br></p><div class="codeBox">int image2_bb_left = image2_x_position;<br>int image2_bb_top = image2_y_position;<br>int image2_bb_right = (image2_bb_left + image2-&gt;w);<br>int image2_bb_bottom = (image2_bb_top + image2-&gt;h);</div><p>  This is just a variable to hold the value of whether we want to show the bounding boxes  or not. We'll see more about it later.<br>  <br>When setting the initial value of this variable we will use an Allegro constant FALSE. There is also the constant TRUE. FALSE and TRUE are useful for doing variable testing, as they take away the ambiguity of doing something like:<br><em> &nbsp;&nbsp;&nbsp;&nbsp;<br>if(variable == 0)</em><br></p><div class="codeBox">int show_bbox = FALSE;</div><p>This is just a variable to hold the value of whether there is a collision taking place or not. We'll see more about it later. <br></p><div class="codeBox">int collision = FALSE;</div><p>Okay, now that we've set up all our variables, we need to make our loop. You've seen this before; it should be familiar.<br></p><div class="codeBox">while(!key[KEY_ESC]) // Keep going until we hit escape.<br>{<br>&nbsp;&nbsp;while(speed_counter &gt; 0) // Do the logic loop while the speed counter is &gt; 0.<br>&nbsp;&nbsp;{</div><p>Things get a little tricky in here. We want to be able to move both images. The controls are described at the beginning of this lesson. Lets make some statements to take care of moving the images. </p><p> Notice how each test is a standalone &quot;if&quot; statement? This will allow for diagonal movement without explicitly coding it in.</p><p> Key checks for image1<br></p><div class="codeBox">if(key[KEY_LEFT])<br>&nbsp;&nbsp;&nbsp;&nbsp;image1_x_position --;&nbsp;//&nbsp;Move image 1 left.  <p> if(key[KEY_RIGHT])<br>  &nbsp;&nbsp;&nbsp;&nbsp;image1_x_position ++;&nbsp;//&nbsp;Move image 1 right.</p>  <p> if(key[KEY_DOWN])<br>  &nbsp;&nbsp;&nbsp;&nbsp;image1_y_position ++;&nbsp;//&nbsp;Move image 1 down.</p>  <p> if(key[KEY_UP])<br>  &nbsp;&nbsp;&nbsp;&nbsp;image1_y_position --;&nbsp;//&nbsp;Move image 1 up.</p></div><p>Key checks for image2 </p><div class="codeBox">if(key[KEY_A])<br>&nbsp;&nbsp;image2_x_position --;&nbsp;//&nbsp;Move image 2 left.<p> if(key[KEY_D])<br>&nbsp;&nbsp;image2_x_position ++;&nbsp;//&nbsp;Move image 2 right.</p><p> if(key[KEY_S])<br>&nbsp;&nbsp;image2_y_position ++;&nbsp;//&nbsp;Move image 2 down.</p><p> if(key[KEY_W])<br>&nbsp;&nbsp;image2_y_position --;&nbsp;//&nbsp;Move image 2 up.</p></div><p>Here's where we use show_bbox.<br>If the space key is held down, it will show. Otherwise, it wont. This only works when the space key is <em>held</em> down.<br></p><div class="codeBox">if(key[KEY_SPACE])<br>&nbsp;&nbsp;show_bbox = TRUE;<p> else if(!key[KEY_SPACE])<br>&nbsp;&nbsp;show_bbox = FALSE;</p></div><p> Things get a little tricky here.Since the player can move the images,we need to update the locations of thebounding boxes. Lets do it just likewe did when we initialized them, usingthe same ideas and principles</p><p> Update image 1's bounding box<br></p><div class="codeBox">image1_bb_left = image1_x_position;<br>image1_bb_top = image1_y_position;<br>image1_bb_right = (image1_bb_left + image1-&gt;w);<br>image1_bb_bottom = (image1_bb_top + image1-&gt;h);</div><p>Update image 2's bounding box.<br></p><div class="codeBox">image2_bb_left = image2_x_position;<br>image2_bb_top = image2_y_position;<br>image2_bb_right = (image2_bb_left + image2-&gt;w);<br>image2_bb_bottom = (image2_bb_top + image2-&gt;h);</div><p>Alright, so now we finally get to actually detecting collisions.  This could easily be written to it's own function, and probably should be. For the sake of simplicity, however, it's inlined here.<br>  <br>  The way we check for collisions is simple. First, we assume there is a collision.</p><div class="codeBox">// Assume that there is a collision <br>  collision = TRUE;</div><p>Next we do a series of checks which can determine if there is actually no collision taking place. This is quite simple, and the logic for one side of the box follows for the rest of the sides. Since we're dealing with boxes,<br> we can say that if the bottom bound of the first box is less than the top bound of the second box, there is no way that the boxes can be colliding. That is, since the bottom bound of the first box is the absolute *lowest*<br> point of all pixels on that box, and that point is less than the top bound of the second box (the absolute *highest*) point, there can be no other point on the first box that intersects the second (and vice versa).</p><div class="codeBox">  <p>// NOTE: This could easily be concatinated to be one big if statement across four or clauses -- but it's split up<br>    //      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for easy reading<br>  if(image1_bb_bottom &lt; image2_bb_top)<br>    {<br>    &nbsp;&nbsp;&nbsp;&nbsp;collision = FALSE;<br>    }<br>    else if(image1_bb_top &gt; image2_bb_bottom)<br>    {<br>    &nbsp;&nbsp;&nbsp;&nbsp;collision = FALSE;<br>    }<br>    else if(image1_bb_right &lt; image2_bb_left)<br>    {<br>    &nbsp;&nbsp;&nbsp;&nbsp;collision = FALSE;<br>    }<br>    else if(image1_bb_left &gt; image2_bb_right)<br>    {<br>    &nbsp;&nbsp;&nbsp;&nbsp;collision = FALSE;<br>    }</p>  </div><p> And we're done!<br></p><div class="codeBox"> speed_counter --; // Decrement the speed counter.<br>} // This is the closing bracket to the (speed_counter &gt; 0) test.</div><p> Time for the drawing stuff!<br></p><div class="codeBox">draw_sprite(buffer, image1, image1_x_position, image1_y_position);&nbsp;//&nbsp;Draw image1<br>draw_sprite(buffer, image2, image2_x_position, image2_y_position);&nbsp;//&nbsp;Draw image2</div><p> Here we do the drawing of the bounding box if the player is hitting space.<br></p><div class="codeBox">if(show_bbox == TRUE)<br>{</div><p> This uses the simple line drawing function of allegro. It should be quite self explanitory. </p><p> <em>line</em>(BITMAP *bmp, int x1, int y1, int x2, int y2, int color);</p><p> How we draw the box is quite simple.  We draw four lines: </p><ul>  <li>A line from the left coordinate to the right coordinate with it's y coordinate corrosponding to the top y coordinate.</li>  <li> Another line with the same idea, except using the bottom y coordinate.</li>  <li>A line from the top coordinate to the bottom coordinate with it's x coordinate corrosponding to the left x coordinate.</li>  <li> Another line with the same idea, except using the right x coordinate.</li></ul><p> Draw image1's bounding box.<br></p><div class="codeBox">line(buffer, image1_bb_left, image1_bb_top, image1_bb_right, image1_bb_top, makecol(255,0,0));<br>line(buffer, image1_bb_left, image1_bb_bottom, image1_bb_right, image1_bb_bottom, makecol(255,0,0));<br>line(buffer, image1_bb_left, image1_bb_top, image1_bb_left, image1_bb_bottom, makecol(255,0,0));<br>line(buffer, image1_bb_right, image1_bb_top, image1_bb_right, image1_bb_bottom, makecol(255,0,0));</div><p>Draw image2's bounding box.<br></p><div class="codeBox">line(buffer, image2_bb_left, image2_bb_top, image2_bb_right, image2_bb_top, makecol(255,0,0));<br>line(buffer, image2_bb_left, image2_bb_bottom, image2_bb_right, image2_bb_bottom, makecol(255,0,0));<br>line(buffer, image2_bb_left, image2_bb_top, image2_bb_left, image2_bb_bottom, makecol(255,0,0));<br>line(buffer, image2_bb_right, image2_bb_top, image2_bb_right, image2_bb_bottom, makecol(255,0,0));</div><p> Just the closing bracket...<br></p><div class="codeBox">}</div><p>Now, if there's a collision, we want to state it!<br></p><div class="codeBox">if(collision == TRUE)<br>{</div><p>This is the allegro text printing function. It prints text to the screen.  It's pretty self explanitory<br><br> <em>textprintf_ex</em>(bitmap, font, x_pos, y_pos, color, transparency, &quot;string&quot;, formatting stuff); <br> <br> It works just like C style printf.<br></p><div class="codeBox">&nbsp;&nbsp;textprintf_ex(buffer, font, 0,0, makecol(255,255,255), -1, &quot;Collision!&quot;);<br>}</div><p> Do the normal blitting of the buffer.<br></p><div class="codeBox">blit(buffer, screen, 0, 0, 0, 0, 640, 480);//Blit the buffer<br>clear(buffer);//Clear the buffer</div><p> Destroy bitmaps and quit.<br></p><div class="codeBox">//Destroy all bitmaps<br>destroy_bitmap(buffer);<br>destroy_bitmap(image1);<br>destroy_bitmap(image2);<p> return 0;<br>  }<br>  END_OF_MAIN()</p></div><p> That's the end of lesson 8. Have fun with your collisions! </p><p><a href="../../downloads/alltut/lesson8.zip">Download Lesson 8 Source</a><br>        <a href="alltut_lesson9.htm">Continue to Lesson 9</a><br>        <a href="alltut_index.htm">Back to the main page</a><br>        <br>    </p></div></div></center></body></html>