<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN""http://www.w3.org/TR/html4/loose.dtd"><html><head><meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"><title>Allegro Newbie Tutorial</title><link href="style1.css" rel="stylesheet" type="text/css"></head><body><center><div class="mainBox">  <div align="left">    <div class="borderBottom"><span class="headerText">Allegro Newbie Tutorial</span> : Lesson 9 - Using Datafiles<br>       <br>        This tutorial will demonstrate how to use allegro datafiles. Allegro Datafiles are a powerful thing that allow you to store multiple peices of data (bitmaps, midi, wavs) in a single location, so you don't have to manage creation/loading of multiple items. It's as simple as loading a datafile once, and unloading it when you're done with it.         <p> In the following comments I will try to describe the process of actually *creating* the datafile. Please note that the utility for creating datafiles comes with a readme, and it will better explain how to use it than I do. If you get stuck trying to create your own datafile, load the one supplied with this tutorial and poke around. </p>        <p> The utility to create datafiles is called &quot;grabber&quot;. It is build when you compile allegro and can be found in the &quot;tools&quot; directory. Go launch it up and take a look. You'll notice it's pretty basic. It contains your standard menus. Next come the &quot;Editing, Header, Prefix, Password&quot; text fields. Below this, to the left is a big white empty list. This is where a list of items that are in your datafile go. To the upper right is &quot;compression&quot; stuff. Don't worry about this for now. Below that is a box which will display information for whichever datafile item you currently have selected. Below this appears a big empty space with nothing in it. When you select an item in your datafile a preview will be shown there, if possible. </p>        <p> Ok. So now onto creating an item for your datafile. I find using the right mouse button for everything much easier than using the main menu. Move your mouse to the big white block in the left side of the grabber utility. Right click. You will see the option of &quot;new&quot; if you're not currently selecting an item (which you shouldn't if you started up the grabber without loading a datafile). </p>        <p> Next, open up the new menu; you'll see you have an option of creating all types of items. What we care about is bitmaps. Create a new bitmap and name it anything. You will notice that there is now a preview of your bitmap that say &quot;Hi.&quot; This is normal. All you have done is create a bitmap structure within your datafile. Now you need to load a real bitmap's data into your structure. Do do this, right click your newly created item in the list and select &quot;Grab...&quot; A dialog will pop up. Select the image you want, and voila! Your bitmap now contains the image! </p>        <p> You can now save your datafile and use it for displaying this bitmap. I wont explain about other data types like sample, or MIDI, as the work in much the same way. Just remember: Create the item; then use &quot;Grab&quot; to put the actual data in the item. After that you're all set. </p>        <p> One thing to keep in mind before saving your datafile is whether you want to create a header file to go along with it. Header files make it easier to use datafiles in code as they will give you names to access a field in the datafile array instead of having to remember the exact location of where everything resides. The header file simply creates a #define out of the name you gave your items when creating the datafile that represents that items position in the datafile structure. This will make more sense as we check out the code. Here we go! </p>        <p> The datafile I created for this tutorial consists of only two images. I also used the &quot;Header:&quot; feature to create a header file out of the datafile items for use in code. *Remember*: NEVER hand edit a header file created by the grabber utility. </p>    </div>    </div>  <div align="left">  We have a new include, along with all the normal allegro setup stuff:<br>    <br>    <div class="codeBox">#include // Include the allegro header file.      <p>#include &quot;datafile_header.h&quot; // Include the header file created by the grabber utility.</p>      <p>/* Timer stuff */ <br>        volatile long speed_counter = 0; // A long integer which will store the value of the<br>  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;speed counter.</p>      <p>void increment_speed_counter() // A function to increment the speed counter<br>        {<br>  &nbsp;&nbsp;&nbsp;speed_counter++; // This will just increment the speed counter by one.<br>  }<br>  END_OF_FUNCTION(increment_speed_counter);&nbsp;//&nbsp;Make sure you tell it that it's the end of the<br>  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;//&nbsp;function (allegro specific)<br>  <br>          int main(int argc, char *argv[])<br>        {<br>&nbsp;&nbsp;&nbsp;allegro_init(); // Initialize Allegro<br>&nbsp;&nbsp;&nbsp;install_keyboard(); // Initialize keyboard routines<br>&nbsp;&nbsp;&nbsp;install_timer(); // Initialize the timer routines</p>      <p> &nbsp;&nbsp;&nbsp;LOCK_VARIABLE(speed_counter); //Used to set the timer - which regulates the game's<br>  &nbsp;&nbsp;&nbsp;LOCK_FUNCTION(increment_speed_counter);//speed.<br>  &nbsp;&nbsp;&nbsp;install_int_ex(increment_speed_counter, BPS_TO_TIMER(60));//Set our BPS<br>  <br>  &nbsp;&nbsp;&nbsp;set_color_depth(15); // Set the color depth<br>  <br>  &nbsp;&nbsp;&nbsp;set_gfx_mode(GFX_AUTODETECT, 640,480,0,0); // Change our graphics mode to 640x480</p>      <p> &nbsp;&nbsp;&nbsp;BITMAP *buffer = create_bitmap(640,480); // Create a buffer for smooth animation.</p>      <p> &nbsp;&nbsp;&nbsp;// Check that the buffer was created correctly<br>  &nbsp;&nbsp;&nbsp;if(buffer == NULL)<br>  &nbsp;&nbsp;&nbsp;{<br>  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;set_gfx_mode(GFX_TEXT,0,0,0,0);<br>  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;allegro_message(&quot;Could not create buffer!&quot;);<br>  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exit(EXIT_FAILURE);<br>  &nbsp;&nbsp;&nbsp;}</p>    </div>    Here we will learn about the DATAFILE structure. A DATAFILE structure is much like a BITMAP structure. You use this to create a pointer to a datafile, and then using that pointer you can load a datafile and then use it in your code. Let's create a datafile called dat. <br><br><div class="codeBox"> DATAFILE *my_datafile = NULL;</div><br>Next, we want to actually load the datafile so we can use it. That's as simple as loading bitmaps: use the load_datafile function. All you pass to this function is the path to your datafile.<br><br><div class="codeBox"> my_datafile = load_datafile(&quot;datafile.dat&quot;);</div><br>You can check for errors while loading datafiles just like with bitmaps, so lets do that here. <em>load_datafile</em> returns NULL on error.<br><br><div class="codeBox"> // Check that the datafile was created correctly<br>if(my_datafile == NULL)<br>{<br>&nbsp;&nbsp;&nbsp;set_gfx_mode(GFX_TEXT,0,0,0,0);<br>&nbsp;&nbsp;&nbsp;allegro_message(&quot;Could not load datafile!&quot;);<br>&nbsp;&nbsp;&nbsp;exit(EXIT_FAILURE);<br>}</div><br>Great, now we've got our datafile loaded, we can use it for whatever we want. In this tutorial I'm only going to use the datafile to draw items to the screen. Nothing else spiffy is going to happen, so we can leave the innards of the logical loop empty save the speed_counter --; line.<br><br><div class="codeBox">while(!key[KEY_ESC]) // Keep going until we hit escape.<br>{<br>&nbsp;&nbsp;&nbsp;while(speed_counter &gt; 0) // Do the logic loop while the speed counter is &gt; 0.<br>&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;speed_counter --; // Decrement the speed counter.<br>&nbsp;&nbsp;&nbsp;}</div><br>Here's where things get fun! Time to use our datafile. The first thing you need to know is that (to think about it in a super simplistic style) a datafile is simply an array of items. So, each item that we have put into the datafile will have a corresponding &quot;cell&quot; in the array. This is what that datafile I created is good for. If you have a huge datafile, you can reference your items by their name in the datafile as opposed to their position number. I'll show you both methods.<p> First, to access any item in a datafile you do it like so my_datafile[ Item Number ].dat </p><p> This represents the item numbered &quot;Item Number&quot; in the datafile, where my_datafile is the name that we used when we created the datafile variable using DATAFILE *. The .dat part is required to pull out the actual data in that cell. </p><p> Let's draw the item at position 0 in the datafile to the screen </p><div class="codeBox"> /* (BITMAP*) is required before my_datafile[0].dat when<br> &nbsp;*&nbsp;using C++ to cast the item in order to prevent warnings/errors<br>&nbsp;* about the type of my_datafile[0].dat being unknown. Try for yourself<br>&nbsp;* to omit it and see if your compiler cares or not.<br>&nbsp;*/<br>draw_sprite(buffer, (BITMAP*)my_datafile[0].dat, 0, 0); </div><br>Alright! So we drew the first item in the datafile to the screen. Let's try the second one!<br><br><div class="codeBox"> draw_sprite(buffer, (BITMAP*)my_datafile[1].dat, 100, 100); </div><br><br>Easy, huh? Very. Now, what if you had hundreds of items in your datafile? How could you possibly remember the number corresponding to each one? It would be very difficult. This is why the grabber utility can create a header file for you. The header file simply creates a #define of each item's name in the datafile and sets it to the number that corresponds to that item.<p> The names of the two bitmaps I created are<br>  little_guy<br>  and<br>  space_ship<br></p><p> So, when I'm drawing stuff from my datafile to the buffer, I can use these names instead of numbers. Watch! </p><div class="codeBox">draw_sprite(buffer, (BITMAP*)my_datafile[little_guy].dat, 200, 200);<br>draw_sprite(buffer, (BITMAP*)my_datafile[space_ship].dat, 300, 300);</div><br><br>One thing to remember when creating datafiles is the names of your items. Don't create names that are going to conflict with other variables in your code. The grabber utility will probably let you name a bitmap &quot;int&quot;, but when you try to use a header file created by the grabber utility that tries to #define int, you're going to run into all sorts of problems.<p> Now, lets close up our code a bit. </p><div class="codeBox">blit(buffer, screen, 0, 0, 0, 0, 640, 480);//Blit the buffer<br>clear(buffer);//Clear the buffer<br>}<p> //Destroy all bitmaps<br>  destroy_bitmap(buffer);</p></div>The last thing to remember about datafiles, like bitmaps, is you need to get rid of them when you're done with them. Just like destroy_bitmap for a bitmap, unload_datafile does the same thing for a datafile. Datafiles take up space in memory when you load them, so always make sure you unload your datafiles!<br><br><div class="codeBox"> unload_datafile(my_datafile);<br>  <br>return 0;<br>}<br>END_OF_MAIN()</div><br>And that's it! You can use this tutorial to help you use different kinds of data (like MIDI or SAMPLE)!<br>    <p>        <a href="alltut_index.htm">Back to the main page</a><br>                <br>    </p></div></div></center></body></html>